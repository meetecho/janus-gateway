/*! \file   janus_streaming.c
 * \author Lorenzo Miniero <lorenzo@meetecho.com>
 * \copyright GNU General Public License v3
 * \brief  Janus Streaming plugin
 * \details  This is a streaming plugin for Janus, allowing WebRTC peers
 * to watch/listen to pre-recorded files or media generated by another tool.
 * Specifically, the plugin currently supports three different type of streams:
 * 
 * -# on-demand streaming of pre-recorded media files (different
 * streaming context for each peer);
 * -# live streaming of pre-recorded media files (shared streaming
 * context for all peers attached to the stream);
 * -# live streaming of media generated by another tool (shared
 * streaming context for all peers attached to the stream).
 * 
 * For what concerns types 1. and 2., considering the proof of concept
 * nature of the implementation the only pre-recorded media files
 * that the plugins supports right now are raw mu-Law and a-Law files:
 * support is of course planned for other additional widespread formats
 * as well.
 * 
 * For what concerns type 3., instead, the plugin is configured
 * to listen on a couple of ports for RTP: this means that the plugin
 * is implemented to receive RTP on those ports and relay them to all
 * peers attached to that stream. Any tool that can generate audio/video
 * RTP streams and specify a destination is good for the purpose: the
 * examples section contains samples that make use of GStreamer (http://gstreamer.freedesktop.org/)
 * but other tools like FFmpeg (http://www.ffmpeg.org/), LibAV (http://libav.org/)
 * or others are fine as well. This makes it really easy to capture and
 * encode whatever you want using your favourite tool, and then have it
 * transparently broadcasted via WebRTC using Janus.
 * 
 * Streams to make available are listed in the plugin configuration file.
 * A pre-filled configuration file is provided in \c conf/janus.plugin.streaming.cfg
 * and includes a stream of every type.
 * 
 * To add more streams or modify the existing ones, you can use the following
 * syntax:
 * 
 * \verbatim
[stream-name]
type = rtp|live|ondemand
       rtp = stream originated by an external tool (e.g., gstreamer or
             ffmpeg) and sent to the plugin via RTP
       live = local file streamed live to multiple listeners
              (multiple listeners = same streaming context)
       ondemand = local file streamed on-demand to a single listener
                  (multiple listeners = different streaming contexts)
id = <unique numeric ID>
description = This is my awesome stream
is_private = yes|no (private streams don't appear when you do a 'list' request)
filename = path to the local file to stream (only for live/ondemand)
secret = <optional password needed for manipulating (e.g., destroying
		or enabling/disabling) the stream>
audio = yes|no (do/don't stream audio)
video = yes|no (do/don't stream video)
   The following options are only valid for the 'rtp' type:
audioport = local port for receiving audio frames
audiopt = <audio RTP payload type> (e.g., 111)
audiortpmap = RTP map of the audio codec (e.g., opus/48000/2)
audiofmtp = Codec specific parameters, if any
videoport = local port for receiving video frames (only for rtp)
videopt = <video RTP payload type> (e.g., 100)
videortpmap = RTP map of the video codec (e.g., VP8/90000)
videofmtp = Codec specific parameters, if any
\endverbatim
 *
 * \section streamapi Streaming API
 * 
 * The Streaming API supports several requests, some of which are
 * synchronous and some asynchronous. There are some situations, though,
 * (invalid JSON, invalid request) which will always result in a
 * synchronous error response even for asynchronous requests. 
 * 
 * \c list , \c create , \c destroy , \c recording , \c enable and
 * \c disable are synchronous requests, which means you'll
 * get a response directly within the context of the transaction. \c list
 * lists all the available streams; \c create allows you to create a new
 * mountpoint dynamically, as an alternative to using the configuration
 * file; \c destroy removes a mountpoint and destroys it; \c recording
 * instructs the plugin on whether or not a live RTP stream should be
 * recorded while it's broadcasted; \c enable and \c disable respectively
 * enable and disable a mountpoint, that is decide whether or not a
 * mountpoint should be available to users without destroying it.
 * 
 * The \c watch , \c start , \c pause , \c switch and \c stop requests
 * instead are all asynchronous, which means you'll get a notification
 * about their success or failure in an event. \c watch asks the plugin
 * to prepare the playout of one of the available streams; \c start
 * starts the actual playout; \c pause allows you to pause a playout
 * without tearing down the PeerConnection; \c switch allows you to
 * switch to a different mountpoint of the same kind (note: only live
 * RTP mountpoints supported as of now) without having to stop and watch
 * the new one; \c stop stops the playout and tears the PeerConnection
 * down.
 * 
 * Actual API docs: TBD.
 * 
 * \ingroup plugins
 * \ref plugins
 */

#include "plugin.h"

#include <jansson.h>
#include <errno.h>
#include <sys/poll.h>
#include <sys/time.h>

#include "../debug.h"
#include "../apierror.h"
#include "../config.h"
#include "../mutex.h"
#include "../rtp.h"
#include "../rtcp.h"
#include "../record.h"
#include "../utils.h"


/* Plugin information */
#define JANUS_STREAMING_VERSION			5
#define JANUS_STREAMING_VERSION_STRING	"0.0.5"
#define JANUS_STREAMING_DESCRIPTION		"This is a streaming plugin for Janus, allowing WebRTC peers to watch/listen to pre-recorded files or media generated by gstreamer."
#define JANUS_STREAMING_NAME			"JANUS Streaming plugin"
#define JANUS_STREAMING_AUTHOR			"Meetecho s.r.l."
#define JANUS_STREAMING_PACKAGE			"janus.plugin.streaming"

/* Plugin methods */
janus_plugin *create(void);
int janus_streaming_init(janus_callbacks *callback, const char *config_path);
void janus_streaming_destroy(void);
int janus_streaming_get_api_compatibility(void);
int janus_streaming_get_version(void);
const char *janus_streaming_get_version_string(void);
const char *janus_streaming_get_description(void);
const char *janus_streaming_get_name(void);
const char *janus_streaming_get_author(void);
const char *janus_streaming_get_package(void);
void janus_streaming_create_session(janus_plugin_session *handle, int *error);
struct janus_plugin_result *janus_streaming_handle_message(janus_plugin_session *handle, char *transaction, char *message, char *sdp_type, char *sdp);
void janus_streaming_setup_media(janus_plugin_session *handle);
void janus_streaming_incoming_rtp(janus_plugin_session *handle, int video, char *buf, int len);
void janus_streaming_incoming_rtcp(janus_plugin_session *handle, int video, char *buf, int len);
void janus_streaming_hangup_media(janus_plugin_session *handle);
void janus_streaming_destroy_session(janus_plugin_session *handle, int *error);
char *janus_streaming_query_session(janus_plugin_session *handle);

/* Plugin setup */
static janus_plugin janus_streaming_plugin =
	JANUS_PLUGIN_INIT (
		.init = janus_streaming_init,
		.destroy = janus_streaming_destroy,

		.get_api_compatibility = janus_streaming_get_api_compatibility,
		.get_version = janus_streaming_get_version,
		.get_version_string = janus_streaming_get_version_string,
		.get_description = janus_streaming_get_description,
		.get_name = janus_streaming_get_name,
		.get_author = janus_streaming_get_author,
		.get_package = janus_streaming_get_package,
		
		.create_session = janus_streaming_create_session,
		.handle_message = janus_streaming_handle_message,
		.setup_media = janus_streaming_setup_media,
		.incoming_rtp = janus_streaming_incoming_rtp,
		.incoming_rtcp = janus_streaming_incoming_rtcp,
		.hangup_media = janus_streaming_hangup_media,
		.destroy_session = janus_streaming_destroy_session,
		.query_session = janus_streaming_query_session,
	);

/* Plugin creator */
janus_plugin *create(void) {
	JANUS_LOG(LOG_VERB, "%s created!\n", JANUS_STREAMING_NAME);
	return &janus_streaming_plugin;
}


/* Useful stuff */
static gint initialized = 0, stopping = 0;
static janus_callbacks *gateway = NULL;
static GThread *handler_thread;
static GThread *watchdog;
static void *janus_streaming_handler(void *data);
static void *janus_streaming_ondemand_thread(void *data);
static void *janus_streaming_filesource_thread(void *data);
static void janus_streaming_relay_rtp_packet(gpointer data, gpointer user_data);
static void *janus_streaming_relay_thread(void *data);

typedef enum janus_streaming_type {
	janus_streaming_type_none = 0,
	janus_streaming_type_live,
	janus_streaming_type_on_demand,
} janus_streaming_type;

typedef enum janus_streaming_source {
	janus_streaming_source_none = 0,
	janus_streaming_source_file,
	janus_streaming_source_rtp,
} janus_streaming_source;

typedef struct janus_streaming_rtp_source {
	gint audio_port;
	gint video_port;
	janus_recorder *arc;	/* The Janus recorder instance for this streams's audio, if enabled */
	janus_recorder *vrc;	/* The Janus recorder instance for this streams's video, if enabled */
} janus_streaming_rtp_source;

typedef struct janus_streaming_file_source {
	char *filename;
} janus_streaming_file_source;

typedef struct janus_streaming_codecs {
	gint audio_pt;
	char *audio_rtpmap;
	char *audio_fmtp;
	gint video_pt;
	char *video_rtpmap;
	char *video_fmtp;
} janus_streaming_codecs;

typedef struct janus_streaming_mountpoint {
	gint64 id;
	char *name;
	char *description;
	gboolean is_private;
	char *secret;
	gboolean enabled;
	gboolean active;
	janus_streaming_type streaming_type;
	janus_streaming_source streaming_source;
	void *source;	/* Can differ according to the source type */
	GDestroyNotify source_destroy;
	janus_streaming_codecs codecs;
	GList/*<unowned janus_streaming_session>*/ *listeners;
	gint64 destroyed;
	janus_mutex mutex;
} janus_streaming_mountpoint;
GHashTable *mountpoints;
janus_mutex mountpoints_mutex;

static void janus_streaming_mountpoint_free(janus_streaming_mountpoint *mp);

/* Helper to create an RTP live source (e.g., from gstreamer/ffmpeg/vlc/etc.) */
janus_streaming_mountpoint *janus_streaming_create_rtp_source(
		uint64_t id, char *name, char *desc,
		gboolean doaudio, uint16_t aport, uint8_t acodec, char *artpmap, char *afmtp,
		gboolean dovideo, uint16_t vport, uint8_t vcodec, char *vrtpmap, char *vfmtp);
/* Helper to create a file/ondemand live source */
janus_streaming_mountpoint *janus_streaming_create_file_source(
		uint64_t id, char *name, char *desc, char *filename,
		gboolean live, gboolean doaudio, gboolean dovideo);


typedef struct janus_streaming_message {
	janus_plugin_session *handle;
	char *transaction;
	json_t *message;
	char *sdp_type;
	char *sdp;
} janus_streaming_message;
static GAsyncQueue *messages = NULL;

void janus_streaming_message_free(janus_streaming_message *msg);
void janus_streaming_message_free(janus_streaming_message *msg) {
	if(!msg)
		return;

	msg->handle = NULL;

	g_free(msg->transaction);
	msg->transaction = NULL;
	if(msg->message)
		json_decref(msg->message);
	msg->message = NULL;
	g_free(msg->sdp_type);
	msg->sdp_type = NULL;
	g_free(msg->sdp);
	msg->sdp = NULL;

	g_free(msg);
}


typedef struct janus_streaming_context {
	/* Needed to fix seq and ts in case of stream switching */
	uint32_t a_last_ssrc, a_last_ts, a_base_ts, a_base_ts_prev,
			v_last_ssrc, v_last_ts, v_base_ts, v_base_ts_prev;
	uint16_t a_last_seq, a_base_seq, a_base_seq_prev,
			v_last_seq, v_base_seq, v_base_seq_prev;
} janus_streaming_context;

typedef struct janus_streaming_session {
	janus_plugin_session *handle;
	janus_streaming_mountpoint *mountpoint;
	gboolean started;
	gboolean paused;
	janus_streaming_context context;
	gboolean stopping;
	guint64 destroyed;	/* Time at which this session was marked as destroyed */
} janus_streaming_session;
static GHashTable *sessions;
static GList *old_sessions;
static janus_mutex sessions_mutex;

/* Packets we get from gstreamer and relay */
typedef struct janus_streaming_rtp_relay_packet {
	rtp_header *data;
	gint length;
	gint is_video;
	uint32_t timestamp;
	uint16_t seq_number;
} janus_streaming_rtp_relay_packet;


/* Error codes */
#define JANUS_STREAMING_ERROR_NO_MESSAGE			450
#define JANUS_STREAMING_ERROR_INVALID_JSON			451
#define JANUS_STREAMING_ERROR_INVALID_REQUEST		452
#define JANUS_STREAMING_ERROR_MISSING_ELEMENT		453
#define JANUS_STREAMING_ERROR_INVALID_ELEMENT		454
#define JANUS_STREAMING_ERROR_NO_SUCH_MOUNTPOINT	455
#define JANUS_STREAMING_ERROR_CANT_CREATE			456
#define JANUS_STREAMING_ERROR_UNAUTHORIZED			457
#define JANUS_STREAMING_ERROR_CANT_SWITCH			458
#define JANUS_STREAMING_ERROR_UNKNOWN_ERROR			470


/* Streaming watchdog/garbage collector (sort of) */
void *janus_streaming_watchdog(void *data);
void *janus_streaming_watchdog(void *data) {
	JANUS_LOG(LOG_INFO, "Streaming watchdog started\n");
	gint64 now = 0;
	while(g_atomic_int_get(&initialized) && !g_atomic_int_get(&stopping)) {
		janus_mutex_lock(&sessions_mutex);
		/* Iterate on all the sessions */
		now = janus_get_monotonic_time();
		if(old_sessions != NULL) {
			GList *sl = old_sessions;
			JANUS_LOG(LOG_HUGE, "Checking %d old Streaming sessions...\n", g_list_length(old_sessions));
			while(sl) {
				janus_streaming_session *session = (janus_streaming_session *)sl->data;
				if(!session) {
					sl = sl->next;
					continue;
				}
				if(now-session->destroyed >= 5*G_USEC_PER_SEC) {
					/* We're lazy and actually get rid of the stuff only after a few seconds */
					JANUS_LOG(LOG_VERB, "Freeing old Streaming session\n");
					GList *rm = sl->next;
					old_sessions = g_list_delete_link(old_sessions, sl);
					sl = rm;
					session->handle = NULL;
					g_free(session);
					session = NULL;
					continue;
				}
				sl = sl->next;
			}
		}
		janus_mutex_unlock(&sessions_mutex);
		g_usleep(500000);
	}
	JANUS_LOG(LOG_INFO, "Streaming watchdog stopped\n");
	return NULL;
}


/* Plugin implementation */
int janus_streaming_init(janus_callbacks *callback, const char *config_path) {
	if(g_atomic_int_get(&stopping)) {
		/* Still stopping from before */
		return -1;
	}
	if(callback == NULL || config_path == NULL) {
		/* Invalid arguments */
		return -1;
	}

	/* Read configuration */
	char filename[255];
	g_snprintf(filename, 255, "%s/%s.cfg", config_path, JANUS_STREAMING_PACKAGE);
	JANUS_LOG(LOG_VERB, "Configuration file: %s\n", filename);
	janus_config *config = janus_config_parse(filename);
	if(config != NULL)
		janus_config_print(config);
	
	mountpoints = g_hash_table_new_full(NULL, NULL, NULL,
	                                    (GDestroyNotify) janus_streaming_mountpoint_free);
	janus_mutex_init(&mountpoints_mutex);
	/* Parse configuration to populate the mountpoints */
	if(config != NULL) {
		janus_config_category *cat = janus_config_get_categories(config);
		while(cat != NULL) {
			if(cat->name == NULL) {
				cat = cat->next;
				continue;
			}
			JANUS_LOG(LOG_VERB, "Adding stream '%s'\n", cat->name);
			janus_config_item *type = janus_config_get_item(cat, "type");
			if(type == NULL || type->value == NULL) {
				JANUS_LOG(LOG_VERB, "  -- Invalid type, skipping stream...\n");
				cat = cat->next;
				continue;
			}
			if(!strcasecmp(type->value, "rtp")) {
				/* RTP live source (e.g., from gstreamer/ffmpeg/vlc/etc.) */
				janus_config_item *id = janus_config_get_item(cat, "id");
				janus_config_item *desc = janus_config_get_item(cat, "description");
				janus_config_item *priv = janus_config_get_item(cat, "is_private");
				janus_config_item *secret = janus_config_get_item(cat, "secret");
				janus_config_item *audio = janus_config_get_item(cat, "audio");
				janus_config_item *video = janus_config_get_item(cat, "video");
				janus_config_item *aport = janus_config_get_item(cat, "audioport");
				janus_config_item *acodec = janus_config_get_item(cat, "audiopt");
				janus_config_item *artpmap = janus_config_get_item(cat, "audiortpmap");
				janus_config_item *afmtp = janus_config_get_item(cat, "audiofmtp");
				janus_config_item *vport = janus_config_get_item(cat, "videoport");
				janus_config_item *vcodec = janus_config_get_item(cat, "videopt");
				janus_config_item *vrtpmap = janus_config_get_item(cat, "videortpmap");
				janus_config_item *vfmtp = janus_config_get_item(cat, "videofmtp");
				gboolean is_private = priv && priv->value && janus_is_true(priv->value);
				gboolean doaudio = audio && audio->value && janus_is_true(audio->value);
				gboolean dovideo = video && video->value && janus_is_true(video->value);
				if(!doaudio && !dovideo) {
					JANUS_LOG(LOG_ERR, "Can't add 'rtp' stream '%s', no audio or video have to be streamed...\n", cat->name);
					cat = cat->next;
					continue;
				}
				if(doaudio &&
						(aport == NULL || aport->value == NULL ||
						acodec == NULL || acodec->value == NULL ||
						artpmap == NULL || artpmap->value == NULL)) {
					JANUS_LOG(LOG_ERR, "Can't add 'rtp' stream '%s', missing mandatory information for audio...\n", cat->name);
					cat = cat->next;
					continue;
				}
				if(dovideo &&
						(vport == NULL || vport->value == NULL ||
						vcodec == NULL || vcodec->value == NULL ||
						vrtpmap == NULL || vrtpmap->value == NULL)) {
					JANUS_LOG(LOG_ERR, "Can't add 'rtp' stream '%s', missing mandatory information for video...\n", cat->name);
					cat = cat->next;
					continue;
				}
				if(id == NULL || id->value == NULL) {
					JANUS_LOG(LOG_VERB, "Missing id for stream '%s', will generate a random one...\n", cat->name);
				} else {
					janus_mutex_lock(&mountpoints_mutex);
					janus_streaming_mountpoint *mp = g_hash_table_lookup(mountpoints, GINT_TO_POINTER(atol(id->value)));
					janus_mutex_unlock(&mountpoints_mutex);
					if(mp != NULL) {
						JANUS_LOG(LOG_WARN, "A stream with the provided ID already exists, skipping '%s'\n", cat->name);
						cat = cat->next;
						continue;
					}
				}
				JANUS_LOG(LOG_VERB, "Audio %s, Video %s\n", doaudio ? "enabled" : "NOT enabled", dovideo ? "enabled" : "NOT enabled");
				janus_streaming_mountpoint *mp = NULL;
				if((mp = janus_streaming_create_rtp_source(
						(id && id->value) ? atoi(id->value) : 0,
						(char *)cat->name,
						desc ? (char *)desc->value : NULL,
						doaudio,
						(aport && aport->value) ? atoi(aport->value) : 0,
						(acodec && acodec->value) ? atoi(acodec->value) : 0,
						artpmap ? (char *)artpmap->value : NULL,
						afmtp ? (char *)afmtp->value : NULL,
						dovideo,
						(vport && vport->value) ? atoi(vport->value) : 0,
						(vcodec && vcodec->value) ? atoi(vcodec->value) : 0,
						vrtpmap ? (char *)vrtpmap->value : NULL,
						vfmtp ? (char *)vfmtp->value : NULL)) == NULL) {
					JANUS_LOG(LOG_ERR, "Error creating 'rtp' stream '%s'...\n", cat->name);
					continue;
				}
				mp->is_private = is_private;
				if(secret && secret->value)
					mp->secret = g_strdup(secret->value);
			} else if(!strcasecmp(type->value, "live")) {
				/* File live source */
				janus_config_item *id = janus_config_get_item(cat, "id");
				janus_config_item *desc = janus_config_get_item(cat, "description");
				janus_config_item *priv = janus_config_get_item(cat, "is_private");
				janus_config_item *secret = janus_config_get_item(cat, "secret");
				janus_config_item *file = janus_config_get_item(cat, "filename");
				janus_config_item *audio = janus_config_get_item(cat, "audio");
				janus_config_item *video = janus_config_get_item(cat, "video");
				if(file == NULL || file->value == NULL) {
					JANUS_LOG(LOG_ERR, "Can't add 'live' stream '%s', missing mandatory information...\n", cat->name);
					cat = cat->next;
					continue;
				}
				gboolean is_private = priv && priv->value && janus_is_true(priv->value);
				gboolean doaudio = audio && audio->value && janus_is_true(audio->value);
				gboolean dovideo = video && video->value && janus_is_true(video->value);
				/* TODO We should support something more than raw a-Law and mu-Law streams... */
				if(!doaudio || dovideo) {
					JANUS_LOG(LOG_ERR, "Can't add 'live' stream '%s', we only support audio file streaming right now...\n", cat->name);
					cat = cat->next;
					continue;
				}
				if(!strstr(file->value, ".alaw") && !strstr(file->value, ".mulaw")) {
					JANUS_LOG(LOG_ERR, "Can't add 'live' stream '%s', unsupported format (we only support raw mu-Law and a-Law files right now)\n", cat->name);
					cat = cat->next;
					continue;
				}
				if(id == NULL || id->value == NULL) {
					JANUS_LOG(LOG_VERB, "Missing id for stream '%s', will generate a random one...\n", cat->name);
				} else {
					janus_mutex_lock(&mountpoints_mutex);
					janus_streaming_mountpoint *mp = g_hash_table_lookup(mountpoints, GINT_TO_POINTER(atol(id->value)));
					janus_mutex_unlock(&mountpoints_mutex);
					if(mp != NULL) {
						JANUS_LOG(LOG_WARN, "A stream with the provided ID already exists, skipping '%s'\n", cat->name);
						cat = cat->next;
						continue;
					}
				}
				janus_streaming_mountpoint *mp = NULL;
				if((mp = janus_streaming_create_file_source(
						(id && id->value) ? atoi(id->value) : 0,
						(char *)cat->name,
						desc ? (char *)desc->value : NULL,
						(char *)file->value,
						TRUE, doaudio, dovideo)) == NULL) {
					JANUS_LOG(LOG_ERR, "Error creating 'live' stream '%s'...\n", cat->name);
					continue;
				}
				mp->is_private = is_private;
				if(secret && secret->value)
					mp->secret = g_strdup(secret->value);
			} else if(!strcasecmp(type->value, "ondemand")) {
				/* mu-Law file on demand source */
				janus_config_item *id = janus_config_get_item(cat, "id");
				janus_config_item *desc = janus_config_get_item(cat, "description");
				janus_config_item *priv = janus_config_get_item(cat, "is_private");
				janus_config_item *secret = janus_config_get_item(cat, "secret");
				janus_config_item *file = janus_config_get_item(cat, "filename");
				janus_config_item *audio = janus_config_get_item(cat, "audio");
				janus_config_item *video = janus_config_get_item(cat, "video");
				if(file == NULL || file->value == NULL) {
					JANUS_LOG(LOG_ERR, "Can't add 'ondemand' stream '%s', missing mandatory information...\n", cat->name);
					cat = cat->next;
					continue;
				}
				gboolean is_private = priv && priv->value && janus_is_true(priv->value);
				gboolean doaudio = audio && audio->value && janus_is_true(audio->value);
				gboolean dovideo = video && video->value && janus_is_true(video->value);
				/* TODO We should support something more than raw a-Law and mu-Law streams... */
				if(!doaudio || dovideo) {
					JANUS_LOG(LOG_ERR, "Can't add 'ondemand' stream '%s', we only support audio file streaming right now...\n", cat->name);
					cat = cat->next;
					continue;
				}
				if(!strstr(file->value, ".alaw") && !strstr(file->value, ".mulaw")) {
					JANUS_LOG(LOG_ERR, "Can't add 'ondemand' stream '%s', unsupported format (we only support raw mu-Law and a-Law files right now)\n", cat->name);
					cat = cat->next;
					continue;
				}
				if(id == NULL || id->value == NULL) {
					JANUS_LOG(LOG_VERB, "Missing id for stream '%s', will generate a random one...\n", cat->name);
				} else {
					janus_mutex_lock(&mountpoints_mutex);
					janus_streaming_mountpoint *mp = g_hash_table_lookup(mountpoints, GINT_TO_POINTER(atol(id->value)));
					janus_mutex_unlock(&mountpoints_mutex);
					if(mp != NULL) {
						JANUS_LOG(LOG_WARN, "A stream with the provided ID already exists, skipping '%s'\n", cat->name);
						cat = cat->next;
						continue;
					}
				}
				janus_streaming_mountpoint *mp = NULL;
				if((mp = janus_streaming_create_file_source(
						(id && id->value) ? atoi(id->value) : 0,
						(char *)cat->name,
						desc ? (char *)desc->value : NULL,
						(char *)file->value,
						FALSE, doaudio, dovideo)) == NULL) {
					JANUS_LOG(LOG_ERR, "Error creating 'ondemand' stream '%s'...\n", cat->name);
					continue;
				}
				mp->is_private = is_private;
				if(secret && secret->value)
					mp->secret = g_strdup(secret->value);
			} else {
				JANUS_LOG(LOG_WARN, "Ignoring unknown stream type '%s' (%s)...\n", type->value, cat->name);
			}
			cat = cat->next;
		}
		/* Done */
		janus_config_destroy(config);
		config = NULL;
	}
	/* Show available mountpoints */
	janus_mutex_lock(&mountpoints_mutex);
	GHashTableIter iter;
	gpointer value;
	g_hash_table_iter_init(&iter, mountpoints);
	while (g_hash_table_iter_next(&iter, NULL, &value)) {
		janus_streaming_mountpoint *mp = value;
		JANUS_LOG(LOG_VERB, "  ::: [%"SCNu64"][%s] %s (%s, %s, %s)\n", mp->id, mp->name, mp->description,
			mp->streaming_type == janus_streaming_type_live ? "live" : "on demand",
			mp->streaming_source == janus_streaming_source_rtp ? "RTP source" : "file source",
			mp->is_private ? "private" : "public");
	}
	janus_mutex_unlock(&mountpoints_mutex);

	sessions = g_hash_table_new(NULL, NULL);
	janus_mutex_init(&sessions_mutex);
	messages = g_async_queue_new_full((GDestroyNotify) janus_streaming_message_free);
	/* This is the callback we'll need to invoke to contact the gateway */
	gateway = callback;
	g_atomic_int_set(&initialized, 1);

	GError *error = NULL;
	/* Start the sessions watchdog */
	watchdog = g_thread_try_new("streaming watchdog", &janus_streaming_watchdog, NULL, &error);
	if(!watchdog) {
		g_atomic_int_set(&initialized, 0);
		JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the Streaming watchdog thread...\n", error->code, error->message ? error->message : "??");
		return -1;
	}
	/* Launch the thread that will handle incoming messages */
	handler_thread = g_thread_try_new("janus streaming handler", janus_streaming_handler, NULL, &error);
	if(error != NULL) {
		g_atomic_int_set(&initialized, 0);
		JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the Streaming handler thread...\n", error->code, error->message ? error->message : "??");
		return -1;
	}
	JANUS_LOG(LOG_INFO, "%s initialized!\n", JANUS_STREAMING_NAME);
	return 0;
}

void janus_streaming_destroy(void) {
	if(!g_atomic_int_get(&initialized))
		return;
	g_atomic_int_set(&stopping, 1);

	if(handler_thread != NULL) {
		g_thread_join(handler_thread);
		handler_thread = NULL;
	}
	if(watchdog != NULL) {
		g_thread_join(watchdog);
		watchdog = NULL;
	}

	/* FIXME We should destroy the sessions cleanly */
	usleep(500000);
	janus_mutex_lock(&mountpoints_mutex);
	g_hash_table_destroy(mountpoints);
	janus_mutex_unlock(&mountpoints_mutex);
	janus_mutex_lock(&sessions_mutex);
	g_hash_table_destroy(sessions);
	janus_mutex_unlock(&sessions_mutex);
	g_async_queue_unref(messages);
	messages = NULL;
	sessions = NULL;

	g_atomic_int_set(&initialized, 0);
	g_atomic_int_set(&stopping, 0);
	JANUS_LOG(LOG_INFO, "%s destroyed!\n", JANUS_STREAMING_NAME);
}

int janus_streaming_get_api_compatibility(void) {
	/* Important! This is what your plugin MUST always return: don't lie here or bad things will happen */
	return JANUS_PLUGIN_API_VERSION;
}

int janus_streaming_get_version(void) {
	return JANUS_STREAMING_VERSION;
}

const char *janus_streaming_get_version_string(void) {
	return JANUS_STREAMING_VERSION_STRING;
}

const char *janus_streaming_get_description(void) {
	return JANUS_STREAMING_DESCRIPTION;
}

const char *janus_streaming_get_name(void) {
	return JANUS_STREAMING_NAME;
}

const char *janus_streaming_get_author(void) {
	return JANUS_STREAMING_AUTHOR;
}

const char *janus_streaming_get_package(void) {
	return JANUS_STREAMING_PACKAGE;
}

void janus_streaming_create_session(janus_plugin_session *handle, int *error) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {
		*error = -1;
		return;
	}	
	janus_streaming_session *session = (janus_streaming_session *)calloc(1, sizeof(janus_streaming_session));
	if(session == NULL) {
		JANUS_LOG(LOG_FATAL, "Memory error!\n");
		*error = -2;
		return;
	}
	session->handle = handle;
	session->mountpoint = NULL;	/* This will happen later */
	session->started = FALSE;	/* This will happen later */
	session->paused = FALSE;
	session->destroyed = 0;
	handle->plugin_handle = session;
	janus_mutex_lock(&sessions_mutex);
	g_hash_table_insert(sessions, handle, session);
	janus_mutex_unlock(&sessions_mutex);

	return;
}

void janus_streaming_destroy_session(janus_plugin_session *handle, int *error) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {
		*error = -1;
		return;
	}	
	janus_streaming_session *session = (janus_streaming_session *)handle->plugin_handle; 
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		*error = -2;
		return;
	}
	JANUS_LOG(LOG_VERB, "Removing streaming session...\n");
	if(session->mountpoint) {
		janus_mutex_lock(&session->mountpoint->mutex);
		session->mountpoint->listeners = g_list_remove_all(session->mountpoint->listeners, session);
		janus_mutex_unlock(&session->mountpoint->mutex);
	}
	janus_mutex_lock(&sessions_mutex);
	g_hash_table_remove(sessions, handle);
	janus_mutex_unlock(&sessions_mutex);
	/* Cleaning up and removing the session is done in a lazy way */
	session->destroyed = janus_get_monotonic_time();
	janus_mutex_lock(&sessions_mutex);
	old_sessions = g_list_append(old_sessions, session);
	janus_mutex_unlock(&sessions_mutex);
	return;
}

char *janus_streaming_query_session(janus_plugin_session *handle) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {
		return NULL;
	}	
	janus_streaming_session *session = (janus_streaming_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		return NULL;
	}
	/* What is this user watching, if anything? */
	json_t *info = json_object();
	json_object_set_new(info, "state", json_string(session->mountpoint ? "watching" : "idle"));
	if(session->mountpoint) {
		json_object_set_new(info, "mountpoint_id", json_integer(session->mountpoint->id));
		json_object_set_new(info, "mountpoint_name", session->mountpoint->name ? json_string(session->mountpoint->name) : NULL);
	}
	json_object_set_new(info, "destroyed", json_integer(session->destroyed));
	char *info_text = json_dumps(info, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
	json_decref(info);
	return info_text;
}

struct janus_plugin_result *janus_streaming_handle_message(janus_plugin_session *handle, char *transaction, char *message, char *sdp_type, char *sdp) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return janus_plugin_result_new(JANUS_PLUGIN_ERROR, g_atomic_int_get(&stopping) ? "Shutting down" : "Plugin not initialized");
	JANUS_LOG(LOG_VERB, "%s\n", message);

	/* Pre-parse the message */
	int error_code = 0;
	char error_cause[512];	/* FIXME 512 should be enough, but anyway... */
	json_t *root = NULL;
	janus_streaming_session *session = (janus_streaming_session *)handle->plugin_handle;	
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		error_code = JANUS_STREAMING_ERROR_UNKNOWN_ERROR;
		g_snprintf(error_cause, 512, "%s", "session associated with this handle...");
		goto error;
	}
	if(session->destroyed) {
		JANUS_LOG(LOG_ERR, "Session has already been destroyed...\n");
		error_code = JANUS_STREAMING_ERROR_UNKNOWN_ERROR;
		g_snprintf(error_cause, 512, "%s", "Session has already been destroyed...");
		goto error;
	}
	error_code = 0;
	JANUS_LOG(LOG_VERB, "Handling message: %s\n", message);
	if(message == NULL) {
		JANUS_LOG(LOG_ERR, "No message??\n");
		error_code = JANUS_STREAMING_ERROR_NO_MESSAGE;
		g_snprintf(error_cause, 512, "%s", "No message??");
		goto error;
	}
	json_error_t error;
	root = json_loads(message, 0, &error);
	if(!root) {
		JANUS_LOG(LOG_ERR, "JSON error: on line %d: %s\n", error.line, error.text);
		error_code = JANUS_STREAMING_ERROR_INVALID_JSON;
		g_snprintf(error_cause, 512, "JSON error: on line %d: %s", error.line, error.text);
		goto error;
	}
	if(!json_is_object(root)) {
		JANUS_LOG(LOG_ERR, "JSON error: not an object\n");
		error_code = JANUS_STREAMING_ERROR_INVALID_JSON;
		g_snprintf(error_cause, 512, "JSON error: not an object");
		goto error;
	}
	/* Get the request first */
	json_t *request = json_object_get(root, "request");
	if(!request) {
		JANUS_LOG(LOG_ERR, "Missing element (request)\n");
		error_code = JANUS_STREAMING_ERROR_MISSING_ELEMENT;
		g_snprintf(error_cause, 512, "Missing element (request)");
		goto error;
	}
	if(!json_is_string(request)) {
		JANUS_LOG(LOG_ERR, "Invalid element (request should be a string)\n");
		error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
		g_snprintf(error_cause, 512, "Invalid element (request should be a string)");
		goto error;
	}
	/* Some requests ('create' and 'destroy') can be handled synchronously */
	const char *request_text = json_string_value(request);
	if(!strcasecmp(request_text, "list")) {
		json_t *list = json_array();
		JANUS_LOG(LOG_VERB, "Request for the list of mountpoints\n");
		/* Return a list of all available mountpoints */
		janus_mutex_lock(&mountpoints_mutex);
		GHashTableIter iter;
		gpointer value;
		g_hash_table_iter_init(&iter, mountpoints);
		while (g_hash_table_iter_next(&iter, NULL, &value)) {
			janus_streaming_mountpoint *mp = value;
			if(mp->is_private) {
				/* Skip private stream */
				JANUS_LOG(LOG_VERB, "Skipping private mountpoint '%s'\n", mp->description);
				continue;
			}
			json_t *ml = json_object();
			json_object_set_new(ml, "id", json_integer(mp->id));
			json_object_set_new(ml, "description", json_string(mp->description));
			json_object_set_new(ml, "type", json_string(mp->streaming_type == janus_streaming_type_live ? "live" : "on demand"));
			json_array_append_new(list, ml);
		}
		janus_mutex_unlock(&mountpoints_mutex);
		/* Send info back */
		json_t *response = json_object();
		json_object_set_new(response, "streaming", json_string("list"));
		json_object_set_new(response, "list", list);
		char *response_text = json_dumps(response, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
		json_decref(response);
		janus_plugin_result *result = janus_plugin_result_new(JANUS_PLUGIN_OK, response_text);
		g_free(response_text);
		return result;
	} else if(!strcasecmp(request_text, "create")) {
		/* Create a new stream */
		json_t *type = json_object_get(root, "type");
		if(!type) {
			JANUS_LOG(LOG_ERR, "Missing element (type)\n");
			error_code = JANUS_STREAMING_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (type)");
			goto error;
		}
		if(!json_is_string(type)) {
			JANUS_LOG(LOG_ERR, "Invalid element (type should be a string)\n");
			error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (type should be a string)");
			goto error;
		}
		const char *type_text = json_string_value(type);
		json_t *secret = json_object_get(root, "secret");
		if(secret && !json_is_string(secret)) {
			JANUS_LOG(LOG_ERR, "Invalid element (secret should be a string)\n");
			error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (secret should be a string)");
			goto error;
		}
		janus_streaming_mountpoint *mp = NULL;
		if(!strcasecmp(type_text, "rtp")) {
			/* RTP live source (e.g., from gstreamer/ffmpeg/vlc/etc.) */
			json_t *id = json_object_get(root, "id");
			if(id && !json_is_integer(id)) {
				JANUS_LOG(LOG_ERR, "Invalid element (id should be an integer)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (id should be an integer)");
				goto error;
			}
			json_t *name = json_object_get(root, "name");
			if(name && !json_is_string(name)) {
				JANUS_LOG(LOG_ERR, "Invalid element (name should be a string)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (name should be a string)");
				goto error;
			}
			json_t *desc = json_object_get(root, "description");
			if(desc && !json_is_string(desc)) {
				JANUS_LOG(LOG_ERR, "Invalid element (desc should be a string)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (desc should be a string)");
				goto error;
			}
			json_t *is_private = json_object_get(root, "is_private");
			if(is_private && !json_is_boolean(is_private)) {
				JANUS_LOG(LOG_ERR, "Invalid element (is_private should be a boolean)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (is_private should be a boolean)");
				goto error;
			}
			json_t *audio = json_object_get(root, "audio");
			if(audio && !json_is_boolean(audio)) {
				JANUS_LOG(LOG_ERR, "Invalid element (audio should be a boolean)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (audio should be a boolean)");
				goto error;
			}
			json_t *video = json_object_get(root, "video");
			if(video && !json_is_boolean(video)) {
				JANUS_LOG(LOG_ERR, "Invalid element (video should be a boolean)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (video should be a boolean)");
				goto error;
			}
			gboolean doaudio = audio ? json_is_true(audio) : FALSE;
			gboolean dovideo = video ? json_is_true(video) : FALSE;
			if(!doaudio && !dovideo) {
				JANUS_LOG(LOG_ERR, "Can't add 'rtp' stream, no audio or video have to be streamed...\n");
				error_code = JANUS_STREAMING_ERROR_CANT_CREATE;
				g_snprintf(error_cause, 512, "Can't add 'rtp' stream, no audio or video have to be streamed...");
				goto error;
			}
			uint16_t aport = 0;
			uint8_t acodec = 0;
			char *artpmap = NULL, *afmtp = NULL;
			if(doaudio) {
				json_t *audioport = json_object_get(root, "audioport");
				if(!audioport) {
					JANUS_LOG(LOG_ERR, "Missing element (audioport)\n");
					error_code = JANUS_STREAMING_ERROR_MISSING_ELEMENT;
					g_snprintf(error_cause, 512, "Missing element (audioport)");
					goto error;
				}
				if(!json_is_integer(audioport)) {
					JANUS_LOG(LOG_ERR, "Invalid element (audioport should be an integer)\n");
					error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (audioport should be an integer)");
					goto error;
				}
				aport = json_integer_value(audioport);
				json_t *audiopt = json_object_get(root, "audiopt");
				if(!audiopt) {
					JANUS_LOG(LOG_ERR, "Missing element (audiopt)\n");
					error_code = JANUS_STREAMING_ERROR_MISSING_ELEMENT;
					g_snprintf(error_cause, 512, "Missing element (audiopt)");
					goto error;
				}
				if(!json_is_integer(audiopt)) {
					JANUS_LOG(LOG_ERR, "Invalid element (audiopt should be an integer)\n");
					error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (audiopt should be an integer)");
					goto error;
				}
				acodec = json_integer_value(audiopt);
				json_t *audiortpmap = json_object_get(root, "audiortpmap");
				if(!audiortpmap) {
					JANUS_LOG(LOG_ERR, "Missing element (audiortpmap)\n");
					error_code = JANUS_STREAMING_ERROR_MISSING_ELEMENT;
					g_snprintf(error_cause, 512, "Missing element (audiortpmap)");
					goto error;
				}
				if(!json_is_string(audiortpmap)) {
					JANUS_LOG(LOG_ERR, "Invalid element (audiortpmap should be a string)\n");
					error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (audiortpmap should be a string)");
					goto error;
				}
				artpmap = (char *)json_string_value(audiortpmap);
				json_t *audiofmtp = json_object_get(root, "audiofmtp");
				if(audiofmtp && !json_is_string(audiofmtp)) {
					JANUS_LOG(LOG_ERR, "Invalid element (audiofmtp should be a string)\n");
					error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (audiofmtp should be a string)");
					goto error;
				}
				afmtp = (char *)json_string_value(audiofmtp);
			}
			uint16_t vport = 0;
			uint8_t vcodec = 0;
			char *vrtpmap = NULL, *vfmtp = NULL;
			if(dovideo) {
				json_t *videoport = json_object_get(root, "videoport");
				if(!videoport) {
					JANUS_LOG(LOG_ERR, "Missing element (videoport)\n");
					error_code = JANUS_STREAMING_ERROR_MISSING_ELEMENT;
					g_snprintf(error_cause, 512, "Missing element (videoport)");
					goto error;
				}
				if(!json_is_integer(videoport)) {
					JANUS_LOG(LOG_ERR, "Invalid element (videoport should be an integer)\n");
					error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (videoport should be an integer)");
					goto error;
				}
				vport = json_integer_value(videoport);
				json_t *videopt = json_object_get(root, "videopt");
				if(!videopt) {
					JANUS_LOG(LOG_ERR, "Missing element (videopt)\n");
					error_code = JANUS_STREAMING_ERROR_MISSING_ELEMENT;
					g_snprintf(error_cause, 512, "Missing element (videopt)");
					goto error;
				}
				if(!json_is_integer(videopt)) {
					JANUS_LOG(LOG_ERR, "Invalid element (videopt should be an integer)\n");
					error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (videopt should be an integer)");
					goto error;
				}
				vcodec = json_integer_value(videopt);
				json_t *videortpmap = json_object_get(root, "videortpmap");
				if(!videortpmap) {
					JANUS_LOG(LOG_ERR, "Missing element (videortpmap)\n");
					error_code = JANUS_STREAMING_ERROR_MISSING_ELEMENT;
					g_snprintf(error_cause, 512, "Missing element (videortpmap)");
					goto error;
				}
				if(!json_is_string(videortpmap)) {
					JANUS_LOG(LOG_ERR, "Invalid element (videortpmap should be a string)\n");
					error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (videortpmap should be a string)");
					goto error;
				}
				vrtpmap = (char *)json_string_value(videortpmap);
				json_t *videofmtp = json_object_get(root, "videofmtp");
				if(videofmtp && !json_is_string(videofmtp)) {
					JANUS_LOG(LOG_ERR, "Invalid element (videofmtp should be a string)\n");
					error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (videofmtp should be a string)");
					goto error;
				}
				vfmtp = (char *)json_string_value(videofmtp);
			}
			if(id == NULL) {
				JANUS_LOG(LOG_VERB, "Missing id, will generate a random one...\n");
			} else {
				janus_mutex_lock(&mountpoints_mutex);
				mp = g_hash_table_lookup(mountpoints, GINT_TO_POINTER(json_integer_value(id)));
				janus_mutex_unlock(&mountpoints_mutex);
				if(mp != NULL) {
					JANUS_LOG(LOG_ERR, "A stream with the provided ID already exists\n");
					error_code = JANUS_STREAMING_ERROR_CANT_CREATE;
					g_snprintf(error_cause, 512, "A stream with the provided ID already exists");
					goto error;
				}
			}
			JANUS_LOG(LOG_VERB, "Audio %s, Video %s\n", doaudio ? "enabled" : "NOT enabled", dovideo ? "enabled" : "NOT enabled");
			mp = janus_streaming_create_rtp_source(
					id ? json_integer_value(id) : 0,
					name ? (char *)json_string_value(name) : NULL,
					desc ? (char *)json_string_value(desc) : NULL,
					doaudio, aport, acodec, artpmap, afmtp,
					dovideo, vport, vcodec, vrtpmap, vfmtp);
			if(mp == NULL) {
				JANUS_LOG(LOG_ERR, "Error creating 'rtp' stream...\n");
				error_code = JANUS_STREAMING_ERROR_CANT_CREATE;
				g_snprintf(error_cause, 512, "Error creating 'rtp' stream");
				goto error;
			}
			mp->is_private = is_private ? json_is_true(is_private) : FALSE;
		} else if(!strcasecmp(type_text, "live")) {
			/* File live source */
			json_t *id = json_object_get(root, "id");
			if(id && !json_is_integer(id)) {
				JANUS_LOG(LOG_ERR, "Invalid element (id should be an integer)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (id should be an integer)");
				goto error;
			}
			json_t *name = json_object_get(root, "name");
			if(name && !json_is_string(name)) {
				JANUS_LOG(LOG_ERR, "Invalid element (name should be a string)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (name should be a string)");
				goto error;
			}
			json_t *desc = json_object_get(root, "description");
			if(desc && !json_is_string(desc)) {
				JANUS_LOG(LOG_ERR, "Invalid element (desc should be a string)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (desc should be a string)");
				goto error;
			}
			json_t *is_private = json_object_get(root, "is_private");
			if(is_private && !json_is_boolean(is_private)) {
				JANUS_LOG(LOG_ERR, "Invalid element (is_private should be a boolean)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (is_private should be a boolean)");
				goto error;
			}
			json_t *file = json_object_get(root, "file");
			if(file && !json_is_string(file)) {
				JANUS_LOG(LOG_ERR, "Invalid element (file should be a string)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (file should be a string)");
				goto error;
			}
			json_t *audio = json_object_get(root, "audio");
			if(audio && !json_is_boolean(audio)) {
				JANUS_LOG(LOG_ERR, "Invalid element (audio should be a boolean)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (audio should be a boolean)");
				goto error;
			}
			json_t *video = json_object_get(root, "video");
			if(video && !json_is_boolean(video)) {
				JANUS_LOG(LOG_ERR, "Invalid element (video should be a boolean)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (video should be a boolean)");
				goto error;
			}
			gboolean doaudio = audio ? json_is_true(audio) : FALSE;
			gboolean dovideo = video ? json_is_true(video) : FALSE;
			/* TODO We should support something more than raw a-Law and mu-Law streams... */
			if(!doaudio || dovideo) {
				JANUS_LOG(LOG_ERR, "Can't add 'live' stream, we only support audio file streaming right now...\n");
				error_code = JANUS_STREAMING_ERROR_CANT_CREATE;
				g_snprintf(error_cause, 512, "Can't add 'live' stream, we only support audio file streaming right now...");
				goto error;
			}
			char *filename = (char *)json_string_value(file);
			if(!strstr(filename, ".alaw") && !strstr(filename, ".mulaw")) {
				JANUS_LOG(LOG_ERR, "Can't add 'live' stream, unsupported format (we only support raw mu-Law and a-Law files right now)\n");
				error_code = JANUS_STREAMING_ERROR_CANT_CREATE;
				g_snprintf(error_cause, 512, "Can't add 'live' stream, unsupported format (we only support raw mu-Law and a-Law files right now)");
				goto error;
			}
			if(id == NULL) {
				JANUS_LOG(LOG_VERB, "Missing id, will generate a random one...\n");
			} else {
				janus_mutex_lock(&mountpoints_mutex);
				mp = g_hash_table_lookup(mountpoints, GINT_TO_POINTER(json_integer_value(id)));
				janus_mutex_unlock(&mountpoints_mutex);
				if(mp != NULL) {
					JANUS_LOG(LOG_ERR, "A stream with the provided ID already exists\n");
					error_code = JANUS_STREAMING_ERROR_CANT_CREATE;
					g_snprintf(error_cause, 512, "A stream with the provided ID already exists");
					goto error;
				}
			}
			mp = janus_streaming_create_file_source(
					id ? json_integer_value(id) : 0,
					name ? (char *)json_string_value(name) : NULL,
					desc ? (char *)json_string_value(desc) : NULL,
					filename,
					TRUE, doaudio, dovideo);
			if(mp == NULL) {
				JANUS_LOG(LOG_ERR, "Error creating 'live' stream...\n");
				error_code = JANUS_STREAMING_ERROR_CANT_CREATE;
				g_snprintf(error_cause, 512, "Error creating 'live' stream");
				goto error;
			}
			mp->is_private = is_private ? json_is_true(is_private) : FALSE;
		} else if(!strcasecmp(type_text, "ondemand")) {
			/* mu-Law file on demand source */
			json_t *id = json_object_get(root, "id");
			if(id && !json_is_integer(id)) {
				JANUS_LOG(LOG_ERR, "Invalid element (id should be an integer)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (id should be an integer)");
				goto error;
			}
			json_t *name = json_object_get(root, "name");
			if(name && !json_is_string(name)) {
				JANUS_LOG(LOG_ERR, "Invalid element (name should be a string)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (name should be a string)");
				goto error;
			}
			json_t *desc = json_object_get(root, "description");
			if(desc && !json_is_string(desc)) {
				JANUS_LOG(LOG_ERR, "Invalid element (desc should be a string)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (desc should be a string)");
				goto error;
			}
			json_t *is_private = json_object_get(root, "is_private");
			if(is_private && !json_is_boolean(is_private)) {
				JANUS_LOG(LOG_ERR, "Invalid element (is_private should be a boolean)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (is_private should be a boolean)");
				goto error;
			}
			json_t *file = json_object_get(root, "file");
			if(file && !json_is_string(file)) {
				JANUS_LOG(LOG_ERR, "Invalid element (file should be a string)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (file should be a string)");
				goto error;
			}
			json_t *audio = json_object_get(root, "audio");
			if(audio && !json_is_boolean(audio)) {
				JANUS_LOG(LOG_ERR, "Invalid element (audio should be a boolean)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (audio should be a boolean)");
				goto error;
			}
			json_t *video = json_object_get(root, "video");
			if(video && !json_is_boolean(video)) {
				JANUS_LOG(LOG_ERR, "Invalid element (video should be a boolean)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (video should be a boolean)");
				goto error;
			}
			gboolean doaudio = audio ? json_is_true(audio) : FALSE;
			gboolean dovideo = video ? json_is_true(video) : FALSE;
			/* TODO We should support something more than raw a-Law and mu-Law streams... */
			if(!doaudio || dovideo) {
				JANUS_LOG(LOG_ERR, "Can't add 'ondemand' stream, we only support audio file streaming right now...\n");
				error_code = JANUS_STREAMING_ERROR_CANT_CREATE;
				g_snprintf(error_cause, 512, "Can't add 'ondemand' stream, we only support audio file streaming right now...");
				goto error;
			}
			char *filename = (char *)json_string_value(file);
			if(!strstr(filename, ".alaw") && !strstr(filename, ".mulaw")) {
				JANUS_LOG(LOG_ERR, "Can't add 'ondemand' stream, unsupported format (we only support raw mu-Law and a-Law files right now)\n");
				error_code = JANUS_STREAMING_ERROR_CANT_CREATE;
				g_snprintf(error_cause, 512, "Can't add 'ondemand' stream, unsupported format (we only support raw mu-Law and a-Law files right now)");
				goto error;
			}
			if(id == NULL) {
				JANUS_LOG(LOG_VERB, "Missing id, will generate a random one...\n");
			} else {
				janus_mutex_lock(&mountpoints_mutex);
				mp = g_hash_table_lookup(mountpoints, GINT_TO_POINTER(json_integer_value(id)));
				janus_mutex_unlock(&mountpoints_mutex);
				if(mp != NULL) {
					JANUS_LOG(LOG_ERR, "A stream with the provided ID already exists\n");
					error_code = JANUS_STREAMING_ERROR_CANT_CREATE;
					g_snprintf(error_cause, 512, "A stream with the provided ID already exists");
					goto error;
				}
			}
			mp = janus_streaming_create_file_source(
					id ? json_integer_value(id) : 0,
					name ? (char *)json_string_value(name) : NULL,
					desc ? (char *)json_string_value(desc) : NULL,
					filename,
					FALSE, doaudio, dovideo);
			if(mp == NULL) {
				JANUS_LOG(LOG_ERR, "Error creating 'ondemand' stream...\n");
				error_code = JANUS_STREAMING_ERROR_CANT_CREATE;
				g_snprintf(error_cause, 512, "Error creating 'ondemand' stream");
				goto error;
			}
			mp->is_private = is_private ? json_is_true(is_private) : FALSE;
		} else {
			JANUS_LOG(LOG_ERR, "Unknown stream type '%s'...\n", type_text);
			error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Unknown stream type '%s'...\n", type_text);
			goto error;
		}
		/* Any secret? */
		if(secret)
			mp->secret = g_strdup(json_string_value(secret));
		/* Send info back */
		json_t *response = json_object();
		json_object_set_new(response, "streaming", json_string("created"));
		json_object_set_new(response, "created", json_string(mp->name));
		json_t *ml = json_object();
		json_object_set_new(ml, "id", json_integer(mp->id));
		json_object_set_new(ml, "description", json_string(mp->description));
		json_object_set_new(ml, "type", json_string(mp->streaming_type == janus_streaming_type_live ? "live" : "on demand"));
		json_object_set_new(ml, "is_private", json_string(mp->is_private ? "true" : "false"));
		json_object_set_new(response, "stream", ml);
		char *response_text = json_dumps(response, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
		json_decref(response);
		janus_plugin_result *result = janus_plugin_result_new(JANUS_PLUGIN_OK, response_text);
		g_free(response_text);
		return result;
	} else if(!strcasecmp(request_text, "destroy")) {
		/* Get rid of an existing stream (notice this doesn't remove it from the config file, though) */
		json_t *id = json_object_get(root, "id");
		if(!id) {
			JANUS_LOG(LOG_ERR, "Missing element (id)\n");
			error_code = JANUS_STREAMING_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (id)");
			goto error;
		}
		if(!json_is_integer(id)) {
			JANUS_LOG(LOG_ERR, "Invalid element (id should be an integer)\n");
			error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (id should be an integer)");
			goto error;
		}
		gint64 id_value = json_integer_value(id);
		janus_mutex_lock(&mountpoints_mutex);
		janus_streaming_mountpoint *mp = g_hash_table_lookup(mountpoints, GINT_TO_POINTER(id_value));
		if(mp == NULL) {
			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_VERB, "No such mountpoint/stream %"SCNu64"\n", id_value);
			error_code = JANUS_STREAMING_ERROR_NO_SUCH_MOUNTPOINT;
			g_snprintf(error_cause, 512, "No such mountpoint/stream %"SCNu64"", id_value);
			goto error;
		}
		if(mp->secret) {
			/* This action requires an authorized user */
			json_t *secret = json_object_get(root, "secret");
			if(!secret) {
				JANUS_LOG(LOG_ERR, "Missing element (secret)\n");
				error_code = JANUS_STREAMING_ERROR_MISSING_ELEMENT;
				g_snprintf(error_cause, 512, "Missing element (secret)");
				goto error;
			}
			if(!json_is_string(secret)) {
				JANUS_LOG(LOG_ERR, "Invalid element (secret should be a string)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (secret should be a string)");
				goto error;
			}
			if(janus_strcmp_const_time(mp->secret, json_string_value(secret), strlen(json_string_value(secret)))) {
				JANUS_LOG(LOG_ERR, "Unauthorized (wrong secret)\n");
				error_code = JANUS_STREAMING_ERROR_UNAUTHORIZED;
				g_snprintf(error_cause, 512, "Unauthorized (wrong secret)");
				goto error;
			}
		}
		JANUS_LOG(LOG_VERB, "Request to unmount mountpoint/stream %"SCNu64"\n", id_value);
		/* FIXME Should we kick the current viewers as well? */
		g_hash_table_remove(mountpoints, GINT_TO_POINTER(id_value));
		janus_mutex_unlock(&mountpoints_mutex);
		/* Send info back */
		json_t *response = json_object();
		json_object_set_new(response, "streaming", json_string("destroyed"));
		json_object_set_new(response, "destroyed", json_integer(id_value));
		char *response_text = json_dumps(response, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
		json_decref(response);
		janus_plugin_result *result = janus_plugin_result_new(JANUS_PLUGIN_OK, response_text);
		g_free(response_text);
		return result;
	} else if(!strcasecmp(request_text, "recording")) {
		/* We can start/stop recording a live, RTP-based stream */
		json_t *action = json_object_get(root, "action");
		if(!action) {
			JANUS_LOG(LOG_ERR, "Missing element (action)\n");
			error_code = JANUS_STREAMING_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (action)");
			goto error;
		}
		if(!json_is_string(action)) {
			JANUS_LOG(LOG_ERR, "Invalid element (action should be a string)\n");
			error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (action should be a string)");
			goto error;
		}
		const char *action_text = json_string_value(action);
		if(strcasecmp(action_text, "start") && strcasecmp(action_text, "stop")) {
			JANUS_LOG(LOG_ERR, "Invalid action (should be start|stop)\n");
			error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid action (should be start|stop)");
			goto error;
		}
		json_t *id = json_object_get(root, "id");
		if(!id) {
			JANUS_LOG(LOG_ERR, "Missing element (id)\n");
			error_code = JANUS_STREAMING_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (id)");
			goto error;
		}
		if(!json_is_integer(id)) {
			JANUS_LOG(LOG_ERR, "Invalid element (id should be an integer)\n");
			error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (id should be an integer)");
			goto error;
		}
		gint64 id_value = json_integer_value(id);
		janus_mutex_lock(&mountpoints_mutex);
		janus_streaming_mountpoint *mp = g_hash_table_lookup(mountpoints, GINT_TO_POINTER(id_value));
		if(mp == NULL) {
			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_VERB, "No such mountpoint/stream %"SCNu64"\n", id_value);
			error_code = JANUS_STREAMING_ERROR_NO_SUCH_MOUNTPOINT;
			g_snprintf(error_cause, 512, "No such mountpoint/stream %"SCNu64"", id_value);
			goto error;
		}
		if(mp->streaming_type != janus_streaming_type_live || mp->streaming_source != janus_streaming_source_rtp) {
			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_ERR, "Recording is only available on RTP-based live streams\n");
			error_code = JANUS_STREAMING_ERROR_INVALID_REQUEST;
			g_snprintf(error_cause, 512, "Recording is only available on RTP-based live streams");
			goto error;
		}
		if(mp->secret) {
			/* This action requires an authorized user */
			json_t *secret = json_object_get(root, "secret");
			if(!secret) {
				JANUS_LOG(LOG_ERR, "Missing element (secret)\n");
				error_code = JANUS_STREAMING_ERROR_MISSING_ELEMENT;
				g_snprintf(error_cause, 512, "Missing element (secret)");
				goto error;
			}
			if(!json_is_string(secret)) {
				JANUS_LOG(LOG_ERR, "Invalid element (secret should be a string)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (secret should be a string)");
				goto error;
			}
			if(janus_strcmp_const_time(mp->secret, json_string_value(secret), strlen(json_string_value(secret)))) {
				JANUS_LOG(LOG_ERR, "Unauthorized (wrong secret)\n");
				error_code = JANUS_STREAMING_ERROR_UNAUTHORIZED;
				g_snprintf(error_cause, 512, "Unauthorized (wrong secret)");
				goto error;
			}
		}
		janus_streaming_rtp_source *source = mp->source;
		if(!strcasecmp(action_text, "start")) {
			/* Start a recording for audio and/or video */
			json_t *audio = json_object_get(root, "audio");
			if(audio && !json_is_string(audio)) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Invalid element (audio should be a string)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (audio should be a string)");
				goto error;
			}
			json_t *video = json_object_get(root, "video");
			if(video && !json_is_string(video)) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Invalid element (video should be a string)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (video should be a string)");
				goto error;
			}
			if((audio && source->arc) || (video && source->vrc)) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Recording for audio and/or video already started for this stream\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_REQUEST;
				g_snprintf(error_cause, 512, "Recording for audio and/or video already started for this stream");
				goto error;
			}
			if(!audio && !video) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Missing audio and/or video\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_REQUEST;
				g_snprintf(error_cause, 512, "Missing audio and/or video");
				goto error;
			}
			if(audio) {
				const char *audiofile = json_string_value(audio);
				source->arc = janus_recorder_create(NULL, 0, (char *)audiofile);
				if(source->arc == NULL) {
					JANUS_LOG(LOG_ERR, "Error starting recorder for audio\n");
				} else {
					JANUS_LOG(LOG_INFO, "[%s] Audio recording started\n", mp->name);
				}
			}
			if(video) {
				const char *videofile = json_string_value(video);
				source->vrc = janus_recorder_create(NULL, 1, (char *)videofile);
				if(source->vrc == NULL) {
					JANUS_LOG(LOG_ERR, "Error starting recorder for video\n");
				} else {
					JANUS_LOG(LOG_INFO, "[%s] Video recording started\n", mp->name);
				}
			}
			janus_mutex_unlock(&mountpoints_mutex);
			/* Send a success response back */
			json_t *response = json_object();
			json_object_set_new(response, "streaming", json_string("ok"));
			char *response_text = json_dumps(response, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			json_decref(response);
			janus_plugin_result *result = janus_plugin_result_new(JANUS_PLUGIN_OK, response_text);
			g_free(response_text);
			return result;
		} else if(!strcasecmp(action_text, "stop")) {
			/* Stop the recording */
			json_t *audio = json_object_get(root, "audio");
			if(audio && !json_is_boolean(audio)) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Invalid element (audio should be a boolean)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (audio should be a boolean)");
				goto error;
			}
			json_t *video = json_object_get(root, "video");
			if(video && !json_is_boolean(video)) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Invalid element (video should be a boolean)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (video should be a boolean)");
				goto error;
			}
			if(!audio && !video) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Missing audio and/or video\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_REQUEST;
				g_snprintf(error_cause, 512, "Missing audio and/or video");
				goto error;
			}
			if(audio && json_is_true(audio) && source->arc) {
				/* Close the audio recording */
				janus_recorder_close(source->arc);
				JANUS_LOG(LOG_INFO, "[%s] Closed audio recording %s\n", mp->name, source->arc->filename ? source->arc->filename : "??");
				janus_recorder *tmp = source->arc;
				source->arc = NULL;
				janus_recorder_free(tmp);
			}
			if(video && json_is_true(video) && source->vrc) {
				/* Close the video recording */
				janus_recorder_close(source->vrc);
				JANUS_LOG(LOG_INFO, "[%s] Closed video recording %s\n", mp->name, source->vrc->filename ? source->vrc->filename : "??");
				janus_recorder *tmp = source->vrc;
				source->vrc = NULL;
				janus_recorder_free(tmp);
			}
			janus_mutex_unlock(&mountpoints_mutex);
			/* Send a success response back */
			json_t *response = json_object();
			json_object_set_new(response, "streaming", json_string("ok"));
			char *response_text = json_dumps(response, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			json_decref(response);
			janus_plugin_result *result = janus_plugin_result_new(JANUS_PLUGIN_OK, response_text);
			g_free(response_text);
			return result;
		}
	} else if(!strcasecmp(request_text, "enable") || !strcasecmp(request_text, "disable")) {
		/* A request to enable/disable a mountpoint */
		json_t *id = json_object_get(root, "id");
		if(!id) {
			JANUS_LOG(LOG_ERR, "Missing element (id)\n");
			error_code = JANUS_STREAMING_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (id)");
			goto error;
		}
		if(!json_is_integer(id)) {
			JANUS_LOG(LOG_ERR, "Invalid element (id should be an integer)\n");
			error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (id should be an integer)");
			goto error;
		}
		gint64 id_value = json_integer_value(id);
		janus_mutex_lock(&mountpoints_mutex);
		janus_streaming_mountpoint *mp = g_hash_table_lookup(mountpoints, GINT_TO_POINTER(id_value));
		if(mp == NULL) {
			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_VERB, "No such mountpoint/stream %"SCNu64"\n", id_value);
			error_code = JANUS_STREAMING_ERROR_NO_SUCH_MOUNTPOINT;
			g_snprintf(error_cause, 512, "No such mountpoint/stream %"SCNu64"", id_value);
			goto error;
		}
		if(mp->secret) {
			/* This action requires an authorized user */
			json_t *secret = json_object_get(root, "secret");
			if(!secret) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Missing element (secret)\n");
				error_code = JANUS_STREAMING_ERROR_MISSING_ELEMENT;
				g_snprintf(error_cause, 512, "Missing element (secret)");
				goto error;
			}
			if(!json_is_string(secret)) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Invalid element (secret should be a string)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (secret should be a string)");
				goto error;
			}
			if(janus_strcmp_const_time(mp->secret, json_string_value(secret), strlen(json_string_value(secret)))) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Unauthorized (wrong secret)\n");
				error_code = JANUS_STREAMING_ERROR_UNAUTHORIZED;
				g_snprintf(error_cause, 512, "Unauthorized (wrong secret)");
				goto error;
			}
		}
		if(!strcasecmp(request_text, "enable")) {
			/* Enable a previously disabled mountpoint */
			JANUS_LOG(LOG_INFO, "[%s] Stream enabled\n", mp->name);
			mp->enabled = TRUE;
			/* FIXME: Should we notify the listeners, or is this up to the controller application? */
		} else {
			/* Disable a previously enabled mountpoint */
			JANUS_LOG(LOG_INFO, "[%s] Stream disabled\n", mp->name);
			mp->enabled = FALSE;
			/* Any recording to close? */
			janus_streaming_rtp_source *source = mp->source;
			if(source->arc) {
				janus_recorder_close(source->arc);
				JANUS_LOG(LOG_INFO, "[%s] Closed audio recording %s\n", mp->name, source->arc->filename ? source->arc->filename : "??");
				janus_recorder *tmp = source->arc;
				source->arc = NULL;
				janus_recorder_free(tmp);
			}
			if(source->vrc) {
				janus_recorder_close(source->vrc);
				JANUS_LOG(LOG_INFO, "[%s] Closed video recording %s\n", mp->name, source->vrc->filename ? source->vrc->filename : "??");
				janus_recorder *tmp = source->vrc;
				source->vrc = NULL;
				janus_recorder_free(tmp);
			}
			/* FIXME: Should we notify the listeners, or is this up to the controller application? */
		}
		janus_mutex_unlock(&mountpoints_mutex);
		/* Send a success response back */
		json_t *response = json_object();
		json_object_set_new(response, "streaming", json_string("ok"));
		char *response_text = json_dumps(response, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
		json_decref(response);
		janus_plugin_result *result = janus_plugin_result_new(JANUS_PLUGIN_OK, response_text);
		g_free(response_text);
		return result;
	} else if(!strcasecmp(request_text, "watch") || !strcasecmp(request_text, "start")
			|| !strcasecmp(request_text, "pause") || !strcasecmp(request_text, "stop")
			|| !strcasecmp(request_text, "switch")) {
		/* These messages are handled asynchronously */
		goto async;
	} else {
		JANUS_LOG(LOG_VERB, "Unknown request '%s'\n", request_text);
		error_code = JANUS_STREAMING_ERROR_INVALID_REQUEST;
		g_snprintf(error_cause, 512, "Unknown request '%s'", request_text);
		goto error;
	}

error:
		{
			if(root != NULL)
				json_decref(root);
			/* Prepare JSON error event */
			json_t *event = json_object();
			json_object_set_new(event, "videoroom", json_string("event"));
			json_object_set_new(event, "error_code", json_integer(error_code));
			json_object_set_new(event, "error", json_string(error_cause));
			char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			json_decref(event);
			janus_plugin_result *result = janus_plugin_result_new(JANUS_PLUGIN_OK, event_text);
			g_free(event_text);
			return result;
		}

async:
		{
			/* All the other requests to this plugin are handled asynchronously */
			janus_streaming_message *msg = calloc(1, sizeof(janus_streaming_message));
			if(msg == NULL) {
				JANUS_LOG(LOG_FATAL, "Memory error!\n");
				return janus_plugin_result_new(JANUS_PLUGIN_ERROR, "Memory error");
			}
			msg->handle = handle;
			msg->transaction = transaction;
			msg->message = root;
			msg->sdp_type = sdp_type;
			msg->sdp = sdp;

			g_async_queue_push(messages, msg);

			return janus_plugin_result_new(JANUS_PLUGIN_OK_WAIT, NULL);
		}
}

void janus_streaming_setup_media(janus_plugin_session *handle) {
	JANUS_LOG(LOG_INFO, "WebRTC media is now available\n");
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	janus_streaming_session *session = (janus_streaming_session *)handle->plugin_handle;	
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		return;
	}
	if(session->destroyed)
		return;
	/* TODO Only start streaming when we get this event */
	session->context.a_last_ssrc = 0;
	session->context.a_last_ssrc = 0;
	session->context.a_last_ts = 0;
	session->context.a_base_ts = 0;
	session->context.a_base_ts_prev = 0;
	session->context.v_last_ssrc = 0;
	session->context.v_last_ts = 0;
	session->context.v_base_ts = 0;
	session->context.v_base_ts_prev = 0;
	session->context.a_last_seq = 0;
	session->context.a_base_seq = 0;
	session->context.a_base_seq_prev = 0;
	session->context.v_last_seq = 0;
	session->context.v_base_seq = 0;
	session->context.v_base_seq_prev = 0;
	session->started = TRUE;
	/* Prepare JSON event */
	json_t *event = json_object();
	json_object_set_new(event, "streaming", json_string("event"));
	json_t *result = json_object();
	json_object_set_new(result, "status", json_string("started"));
	json_object_set(event, "result", result);
	char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
	json_decref(event);
	json_decref(result);
	JANUS_LOG(LOG_VERB, "Pushing event: %s\n", event_text);
	int ret = gateway->push_event(handle, &janus_streaming_plugin, NULL, event_text, NULL, NULL);
	JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
	g_free(event_text);
}

void janus_streaming_incoming_rtp(janus_plugin_session *handle, int video, char *buf, int len) {
	if(handle == NULL || handle->stopped || g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	/* FIXME We don't care about what the browser sends us, we're sendonly */
}

void janus_streaming_incoming_rtcp(janus_plugin_session *handle, int video, char *buf, int len) {
	if(handle == NULL || handle->stopped || g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	/* We might interested in the available bandwidth that the user advertizes */
	uint64_t bw = janus_rtcp_get_remb(buf, len);
	if(bw > 0) {
		JANUS_LOG(LOG_HUGE, "REMB for this PeerConnection: %"SCNu64"\n", bw);
		/* TODO Use this somehow (e.g., notification towards application?) */
	}
	/* FIXME Maybe we should care about RTCP, but not now */
}

void janus_streaming_hangup_media(janus_plugin_session *handle) {
	JANUS_LOG(LOG_INFO, "No WebRTC media anymore\n");
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	janus_streaming_session *session = (janus_streaming_session *)handle->plugin_handle;	
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		return;
	}
	if(session->destroyed)
		return;
	/* FIXME Simulate a "stop" coming from the browser */
	janus_streaming_message *msg = calloc(1, sizeof(janus_streaming_message));
	if(msg == NULL) {
		JANUS_LOG(LOG_FATAL, "Memory error!\n");
		return;
	}
	msg->handle = handle;
	msg->message = json_loads("{\"request\":\"stop\"}", 0, NULL);
	msg->transaction = NULL;
	msg->sdp_type = NULL;
	msg->sdp = NULL;
	g_async_queue_push(messages, msg);
}

/* Thread to handle incoming messages */
static void *janus_streaming_handler(void *data) {
	JANUS_LOG(LOG_VERB, "Joining Streaming handler thread\n");
	janus_streaming_message *msg = NULL;
	int error_code = 0;
	char *error_cause = calloc(1024, sizeof(char));
	if(error_cause == NULL) {
		JANUS_LOG(LOG_FATAL, "Memory error!\n");
		return NULL;
	}
	json_t *root = NULL;
	while(g_atomic_int_get(&initialized) && !g_atomic_int_get(&stopping)) {
		if(!messages || (msg = g_async_queue_try_pop(messages)) == NULL) {
			usleep(50000);
			continue;
		}
		janus_streaming_session *session = (janus_streaming_session *)msg->handle->plugin_handle;
		if(!session) {
			JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
			janus_streaming_message_free(msg);
			continue;
		}
		if(session->destroyed) {
			janus_streaming_message_free(msg);
			continue;
		}
		/* Handle request */
		error_code = 0;
		root = NULL;
		if(msg->message == NULL) {
			JANUS_LOG(LOG_ERR, "No message??\n");
			error_code = JANUS_STREAMING_ERROR_NO_MESSAGE;
			g_snprintf(error_cause, 512, "%s", "No message??");
			goto error;
		}
		root = msg->message;
		/* Get the request first */
		json_t *request = json_object_get(root, "request");
		if(!request) {
			JANUS_LOG(LOG_ERR, "Missing element (request)\n");
			error_code = JANUS_STREAMING_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (request)");
			goto error;
		}
		if(!json_is_string(request)) {
			JANUS_LOG(LOG_ERR, "Invalid element (request should be a string)\n");
			error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (request should be a string)");
			goto error;
		}
		const char *request_text = json_string_value(request);
		json_t *result = NULL;
		const char *sdp_type = NULL;
		char *sdp = NULL;
		/* All these requests can only be handled asynchronously */
		if(!strcasecmp(request_text, "watch")) {
			json_t *id = json_object_get(root, "id");
			if(!id) {
				JANUS_LOG(LOG_ERR, "Missing element (id)\n");
				error_code = JANUS_STREAMING_ERROR_MISSING_ELEMENT;
				g_snprintf(error_cause, 512, "Missing element (id)");
				goto error;
			}
			if(!json_is_integer(id)) {
				JANUS_LOG(LOG_ERR, "Invalid element (id should be an integer)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (id should be an integer)");
				goto error;
			}
			gint64 id_value = json_integer_value(id);
			janus_mutex_lock(&mountpoints_mutex);
			janus_streaming_mountpoint *mp = g_hash_table_lookup(mountpoints, GINT_TO_POINTER(id_value));
			if(mp == NULL) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_VERB, "No such mountpoint/stream %"SCNu64"\n", id_value);
				error_code = JANUS_STREAMING_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "No such mountpoint/stream %"SCNu64"", id_value);
				goto error;
			}
			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_VERB, "Request to watch mountpoint/stream %"SCNu64"\n", id_value);
			session->stopping = FALSE;
			session->mountpoint = mp;
			if(mp->streaming_type == janus_streaming_type_on_demand) {
				GError *error = NULL;
				g_thread_try_new(session->mountpoint->name, &janus_streaming_ondemand_thread, session, &error);
				if(error != NULL) {
					JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the on-demand thread...\n", error->code, error->message ? error->message : "??");
					error_code = JANUS_STREAMING_ERROR_UNKNOWN_ERROR;
					g_snprintf(error_cause, 512, "Got error %d (%s) trying to launch the on-demand thread", error->code, error->message ? error->message : "??");
					goto error;
				}
			}
			/* TODO Check if user is already watching a stream, if the video is active, etc. */
			janus_mutex_lock(&mp->mutex);
			mp->listeners = g_list_append(mp->listeners, session);
			janus_mutex_unlock(&mp->mutex);
			sdp_type = "offer";	/* We're always going to do the offer ourselves, never answer */
			char sdptemp[2048];
			memset(sdptemp, 0, 2048);
			gchar buffer[512];
			memset(buffer, 0, 512);
			gint64 sessid = janus_get_monotonic_time();
			gint64 version = sessid;	/* FIXME This needs to be increased when it changes, so time should be ok */
			g_snprintf(buffer, 512,
				"v=0\r\no=%s %"SCNu64" %"SCNu64" IN IP4 127.0.0.1\r\n",
					"-", sessid, version);
			g_strlcat(sdptemp, buffer, 2048);
			g_strlcat(sdptemp, "s=Streaming Test\r\nt=0 0\r\n", 2048);
			if(mp->codecs.audio_pt >= 0) {
				/* Add audio line */
				g_snprintf(buffer, 512,
					"m=audio 1 RTP/SAVPF %d\r\n"
					"c=IN IP4 1.1.1.1\r\n",
					mp->codecs.audio_pt);
				g_strlcat(sdptemp, buffer, 2048);
				if(mp->codecs.audio_rtpmap) {
					g_snprintf(buffer, 512,
						"a=rtpmap:%d %s\r\n",
						mp->codecs.audio_pt, mp->codecs.audio_rtpmap);
					g_strlcat(sdptemp, buffer, 2048);
				}
				if(mp->codecs.audio_fmtp) {
					g_snprintf(buffer, 512,
						"a=fmtp:%d %s\r\n",
						mp->codecs.audio_pt, mp->codecs.audio_fmtp);
					g_strlcat(sdptemp, buffer, 2048);
				}
				g_strlcat(sdptemp, "a=sendonly\r\n", 2048);
			}
			if(mp->codecs.video_pt >= 0) {
				/* Add video line */
				g_snprintf(buffer, 512,
					"m=video 1 RTP/SAVPF %d\r\n"
					"c=IN IP4 1.1.1.1\r\n",
					mp->codecs.video_pt);
				g_strlcat(sdptemp, buffer, 2048);
				if(mp->codecs.video_rtpmap) {
					g_snprintf(buffer, 512,
						"a=rtpmap:%d %s\r\n",
						mp->codecs.video_pt, mp->codecs.video_rtpmap);
					g_strlcat(sdptemp, buffer, 2048);
				}
				if(mp->codecs.video_fmtp) {
					g_snprintf(buffer, 512,
						"a=fmtp:%d %s\r\n",
						mp->codecs.video_pt, mp->codecs.video_fmtp);
					g_strlcat(sdptemp, buffer, 2048);
				}
				g_snprintf(buffer, 512,
					"a=rtcp-fb:%d nack\r\n",
					mp->codecs.video_pt);
				g_strlcat(sdptemp, buffer, 2048);
				g_snprintf(buffer, 512,
					"a=rtcp-fb:%d goog-remb\r\n",
					mp->codecs.video_pt);
				g_strlcat(sdptemp, buffer, 2048);
				g_strlcat(sdptemp, "a=sendonly\r\n", 2048);
			}
			sdp = g_strdup(sdptemp);
			JANUS_LOG(LOG_VERB, "Going to offer this SDP:\n%s\n", sdp);
			result = json_object();
			json_object_set_new(result, "status", json_string("preparing"));
		} else if(!strcasecmp(request_text, "start")) {
			if(session->mountpoint == NULL) {
				JANUS_LOG(LOG_VERB, "Can't start: no mountpoint set\n");
				error_code = JANUS_STREAMING_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "Can't start: no mountpoint set");
				goto error;
			}
			JANUS_LOG(LOG_VERB, "Starting the streaming\n");
			session->paused = FALSE;
			result = json_object();
			/* We wait for the setup_media event to start: on the other hand, it may have already arrived */
			json_object_set_new(result, "status", json_string(session->started ? "started" : "starting"));
		} else if(!strcasecmp(request_text, "pause")) {
			if(session->mountpoint == NULL) {
				JANUS_LOG(LOG_VERB, "Can't pause: no mountpoint set\n");
				error_code = JANUS_STREAMING_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "Can't start: no mountpoint set");
				goto error;
			}
			JANUS_LOG(LOG_VERB, "Pausing the streaming\n");
			session->paused = TRUE;
			result = json_object();
			json_object_set_new(result, "status", json_string("pausing"));
		} else if(!strcasecmp(request_text, "switch")) {
			/* This listener wants to switch to a different mountpoint
			 * NOTE: this only works for live RTP streams as of now: you
			 * cannot, for instance, switch from a live RTP mountpoint to
			 * an on demand one or viceversa (TBD.) */
			janus_streaming_mountpoint *oldmp = session->mountpoint;
			if(oldmp == NULL) {
				JANUS_LOG(LOG_VERB, "Can't switch: not on a mountpoint\n");
				error_code = JANUS_STREAMING_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "Can't switch: not on a mountpoint");
				goto error;
			}
			if(oldmp->streaming_type != janus_streaming_type_live || 
					oldmp->streaming_source != janus_streaming_source_rtp) {
				JANUS_LOG(LOG_VERB, "Can't switch: not on a live RTP mountpoint\n");
				error_code = JANUS_STREAMING_ERROR_CANT_SWITCH;
				g_snprintf(error_cause, 512, "Can't switch: not on a live RTP mountpoint");
				goto error;
			}
			json_t *id = json_object_get(root, "id");
			if(!id) {
				JANUS_LOG(LOG_ERR, "Missing element (id)\n");
				error_code = JANUS_STREAMING_ERROR_MISSING_ELEMENT;
				g_snprintf(error_cause, 512, "Missing element (id)");
				goto error;
			}
			if(!json_is_integer(id)) {
				JANUS_LOG(LOG_ERR, "Invalid element (id should be an integer)\n");
				error_code = JANUS_STREAMING_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (id should be an integer)");
				goto error;
			}
			gint64 id_value = json_integer_value(id);
			janus_mutex_lock(&mountpoints_mutex);
			janus_streaming_mountpoint *mp = g_hash_table_lookup(mountpoints, GINT_TO_POINTER(id_value));
			if(mp == NULL) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_VERB, "No such mountpoint/stream %"SCNu64"\n", id_value);
				error_code = JANUS_STREAMING_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "No such mountpoint/stream %"SCNu64"", id_value);
				goto error;
			}
			if(mp->streaming_type != janus_streaming_type_live || 
					mp->streaming_source != janus_streaming_source_rtp) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_VERB, "Can't switch: target is not a live RTP mountpoint\n");
				error_code = JANUS_STREAMING_ERROR_CANT_SWITCH;
				g_snprintf(error_cause, 512, "Can't switch: target is not a live RTP mountpoint");
				goto error;
			}
			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_VERB, "Request to switch to mountpoint/stream %"SCNu64" (old: %"SCNu64")\n", id_value, oldmp->id);
			session->paused = TRUE;
			/* Unsubscribe from the previous mountpoint and subscribe to the new one */
			janus_mutex_lock(&oldmp->mutex);
			oldmp->listeners = g_list_remove_all(oldmp->listeners, session);
			janus_mutex_unlock(&oldmp->mutex);
			/* Subscribe to the new one */
			janus_mutex_lock(&mp->mutex);
			mp->listeners = g_list_append(mp->listeners, session);
			janus_mutex_unlock(&mp->mutex);
			session->mountpoint = mp;
			session->paused = FALSE;
			/* Done */
			result = json_object();
			json_object_set_new(result, "streaming", json_string("event"));
			json_object_set_new(result, "switched", json_string("ok"));
			json_object_set_new(result, "id", json_integer(id_value));
		} else if(!strcasecmp(request_text, "stop")) {
			if(session->stopping || !session->started) {
				/* Been there, done that: ignore */
				janus_streaming_message_free(msg);
				continue;
			}
			JANUS_LOG(LOG_VERB, "Stopping the streaming\n");
			session->stopping = TRUE;
			session->started = FALSE;
			session->paused = FALSE;
			result = json_object();
			json_object_set_new(result, "status", json_string("stopping"));
			if(session->mountpoint) {
				janus_mutex_lock(&session->mountpoint->mutex);
				JANUS_LOG(LOG_VERB, "  -- Removing the session from the mountpoint listeners\n");
				if(g_list_find(session->mountpoint->listeners, session) != NULL) {
					JANUS_LOG(LOG_VERB, "  -- -- Found!\n");
				}
				session->mountpoint->listeners = g_list_remove_all(session->mountpoint->listeners, session);
				janus_mutex_unlock(&session->mountpoint->mutex);
			}
			session->mountpoint = NULL;
			/* Tell the core to tear down the PeerConnection, hangup_media will do the rest */
			gateway->close_pc(session->handle);
		} else {
			JANUS_LOG(LOG_VERB, "Unknown request '%s'\n", request_text);
			error_code = JANUS_STREAMING_ERROR_INVALID_REQUEST;
			g_snprintf(error_cause, 512, "Unknown request '%s'", request_text);
			goto error;
		}
		
		/* Any SDP to handle? */
		if(msg->sdp) {
			JANUS_LOG(LOG_VERB, "This is involving a negotiation (%s) as well (but we really don't care):\n%s\n", msg->sdp_type, msg->sdp);
		}

		/* Prepare JSON event */
		json_t *event = json_object();
		json_object_set_new(event, "streaming", json_string("event"));
		if(result != NULL)
			json_object_set(event, "result", result);
		char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
		json_decref(event);
		if(result != NULL)
			json_decref(result);
		JANUS_LOG(LOG_VERB, "Pushing event: %s\n", event_text);
		int ret = gateway->push_event(msg->handle, &janus_streaming_plugin, msg->transaction, event_text, sdp_type, sdp);
		JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
		g_free(event_text);
		if(sdp)
			g_free(sdp);
		janus_streaming_message_free(msg);
		continue;
		
error:
		{
			/* Prepare JSON error event */
			json_t *event = json_object();
			json_object_set_new(event, "streaming", json_string("event"));
			json_object_set_new(event, "error_code", json_integer(error_code));
			json_object_set_new(event, "error", json_string(error_cause));
			char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			json_decref(event);
			JANUS_LOG(LOG_VERB, "Pushing event: %s\n", event_text);
			int ret = gateway->push_event(msg->handle, &janus_streaming_plugin, msg->transaction, event_text, NULL, NULL);
			JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
			g_free(event_text);
			janus_streaming_message_free(msg);
		}
	}
	g_free(error_cause);
	JANUS_LOG(LOG_VERB, "Leaving Streaming handler thread\n");
	return NULL;
}


/* Helpers to destroy a streaming mountpoint. */
static void janus_streaming_rtp_source_free(janus_streaming_rtp_source *source)
{
	free(source);
}

static void janus_streaming_file_source_free(janus_streaming_file_source *source) {
	g_free(source->filename);
	free(source);
}

static void janus_streaming_mountpoint_free(janus_streaming_mountpoint *mp) {
	mp->destroyed = janus_get_monotonic_time();
	
	g_free(mp->name);
	g_free(mp->description);
	janus_mutex_lock(&mp->mutex);
	g_list_free(mp->listeners);
	janus_mutex_unlock(&mp->mutex);

	if (mp->source != NULL && mp->source_destroy != NULL) {
		mp->source_destroy(mp->source);
	}

	g_free(mp->codecs.audio_rtpmap);
	g_free(mp->codecs.audio_fmtp);
	g_free(mp->codecs.video_rtpmap);
	g_free(mp->codecs.video_fmtp);

	free(mp);
}


/* Helper to create an RTP live source (e.g., from gstreamer/ffmpeg/vlc/etc.) */
janus_streaming_mountpoint *janus_streaming_create_rtp_source(
		uint64_t id, char *name, char *desc,
		gboolean doaudio, uint16_t aport, uint8_t acodec, char *artpmap, char *afmtp,
		gboolean dovideo, uint16_t vport, uint8_t vcodec, char *vrtpmap, char *vfmtp) {
	if(name == NULL) {
		JANUS_LOG(LOG_VERB, "Missing name, will generate a random one...\n");
	}
	if(id == 0) {
		JANUS_LOG(LOG_VERB, "Missing id, will generate a random one...\n");
	}
	if(!doaudio && !dovideo) {
		JANUS_LOG(LOG_ERR, "Can't add 'rtp' stream, no audio or video have to be streamed...\n");
		return NULL;
	}
	if(doaudio && (aport == 0 || artpmap == NULL)) {
		JANUS_LOG(LOG_ERR, "Can't add 'rtp' stream, missing mandatory information for audio...\n");
		return NULL;
	}
	if(dovideo && (vport == 0 || vcodec == 0 || vrtpmap == NULL)) {
		JANUS_LOG(LOG_ERR, "Can't add 'rtp' stream, missing mandatory information for video...\n");
		return NULL;
	}
	JANUS_LOG(LOG_VERB, "Audio %s, Video %s\n", doaudio ? "enabled" : "NOT enabled", dovideo ? "enabled" : "NOT enabled");
	janus_streaming_mountpoint *live_rtp = calloc(1, sizeof(janus_streaming_mountpoint));
	if(live_rtp == NULL) {
		JANUS_LOG(LOG_FATAL, "Memory error!\n");
		return NULL;
	}
	live_rtp->id = id ? id : g_random_int();
	char tempname[255];
	if(!name) {
		memset(tempname, 0, 255);
		g_snprintf(tempname, 255, "%"SCNu64, live_rtp->id);
	}
	live_rtp->name = g_strdup(name ? name : tempname);
	char *description = NULL;
	if(desc != NULL)
		description = g_strdup(desc);
	else
		description = g_strdup(name ? name : tempname);
	live_rtp->description = description;
	live_rtp->enabled = TRUE;
	live_rtp->active = FALSE;
	live_rtp->streaming_type = janus_streaming_type_live;
	live_rtp->streaming_source = janus_streaming_source_rtp;
	janus_streaming_rtp_source *live_rtp_source = calloc(1, sizeof(janus_streaming_rtp_source));
	if(live_rtp->name == NULL || description == NULL || live_rtp_source == NULL) {
		JANUS_LOG(LOG_FATAL, "Memory error!\n");
		if(live_rtp->name)
			g_free(live_rtp->name);
		if(description)
			g_free(description);
		if(live_rtp_source)
			g_free(live_rtp_source);
		g_free(live_rtp);
		return NULL;
	}
	live_rtp_source->audio_port = doaudio ? aport : -1;
	live_rtp_source->video_port = dovideo ? vport : -1;
	live_rtp_source->arc = NULL;
	live_rtp_source->vrc = NULL;
	live_rtp->source = live_rtp_source;
	live_rtp->source_destroy = (GDestroyNotify) janus_streaming_rtp_source_free;
	live_rtp->codecs.audio_pt = doaudio ? acodec : -1;
	live_rtp->codecs.audio_rtpmap = doaudio ? g_strdup(artpmap) : NULL;
	live_rtp->codecs.audio_fmtp = doaudio ? (afmtp ? g_strdup(afmtp) : NULL) : NULL;
	live_rtp->codecs.video_pt = dovideo ? vcodec : -1;
	live_rtp->codecs.video_rtpmap = dovideo ? g_strdup(vrtpmap) : NULL;
	live_rtp->codecs.video_fmtp = dovideo ? (vfmtp ? g_strdup(vfmtp) : NULL) : NULL;
	live_rtp->listeners = NULL;
	live_rtp->destroyed = 0;
	janus_mutex_init(&live_rtp->mutex);
	janus_mutex_lock(&mountpoints_mutex);
	g_hash_table_insert(mountpoints, GINT_TO_POINTER(live_rtp->id), live_rtp);
	janus_mutex_unlock(&mountpoints_mutex);
	GError *error = NULL;
	g_thread_try_new(live_rtp->name, &janus_streaming_relay_thread, live_rtp, &error);
	if(error != NULL) {
		JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the RTP thread...\n", error->code, error->message ? error->message : "??");
		if(live_rtp->name)
			g_free(live_rtp->name);
		if(description)
			g_free(description);
		if(live_rtp_source)
			g_free(live_rtp_source);
		g_free(live_rtp);
		return NULL;
	}
	return live_rtp;
}

/* Helper to create a file/ondemand live source */
janus_streaming_mountpoint *janus_streaming_create_file_source(
		uint64_t id, char *name, char *desc, char *filename,
		gboolean live, gboolean doaudio, gboolean dovideo) {
	if(filename == NULL) {
		JANUS_LOG(LOG_ERR, "Can't add 'live' stream, missing filename...\n");
		return NULL;
	}
	if(name == NULL) {
		JANUS_LOG(LOG_VERB, "Missing name, will generate a random one...\n");
	}
	if(id == 0) {
		JANUS_LOG(LOG_VERB, "Missing id, will generate a random one...\n");
	}
	if(!doaudio && !dovideo) {
		JANUS_LOG(LOG_ERR, "Can't add 'file' stream, no audio or video have to be streamed...\n");
		return NULL;
	}
	/* FIXME We don't support video streaming from file yet */
	if(!doaudio || dovideo) {
		JANUS_LOG(LOG_ERR, "Can't add 'file' stream, we only support audio file streaming right now...\n");
		return NULL;
	}
	/* TODO We should support something more than raw a-Law and mu-Law streams... */
	if(!strstr(filename, ".alaw") && !strstr(filename, ".mulaw")) {
		JANUS_LOG(LOG_ERR, "Can't add 'file' stream, unsupported format (we only support raw mu-Law and a-Law files right now)\n");
		return NULL;
	}
	janus_streaming_mountpoint *file_source = calloc(1, sizeof(janus_streaming_mountpoint));
	if(file_source == NULL) {
		JANUS_LOG(LOG_FATAL, "Memory error!\n");
		return NULL;
	}
	file_source->id = id ? id : g_random_int();
	char tempname[255];
	if(!name) {
		memset(tempname, 0, 255);
		g_snprintf(tempname, 255, "%"SCNu64, file_source->id);
	}
	file_source->name = g_strdup(name ? name : tempname);
	char *description = NULL;
	if(desc != NULL)
		description = g_strdup(desc);
	else
		description = g_strdup(name ? name : tempname);
	file_source->description = description;
	file_source->enabled = TRUE;
	file_source->active = FALSE;
	file_source->streaming_type = live ? janus_streaming_type_live : janus_streaming_type_on_demand;
	file_source->streaming_source = janus_streaming_source_file;
	janus_streaming_file_source *file_source_source = calloc(1, sizeof(janus_streaming_file_source));
	if(file_source->name == NULL || description == NULL || file_source_source == NULL) {
		JANUS_LOG(LOG_FATAL, "Memory error!\n");
		if(file_source->name)
			g_free(file_source->name);
		if(description)
			g_free(description);
		if(file_source_source)
			g_free(file_source_source);
		g_free(file_source);
		return NULL;
	}
	file_source_source->filename = g_strdup(filename);
	file_source->source = file_source_source;
	file_source->source_destroy = (GDestroyNotify) janus_streaming_file_source_free;
	file_source->codecs.audio_pt = strstr(filename, ".alaw") ? 8 : 0;
	file_source->codecs.audio_rtpmap = g_strdup(strstr(filename, ".alaw") ? "PCMA/8000" : "PCMU/8000");
	file_source->codecs.video_pt = -1;	/* FIXME We don't support video for this type yet */
	file_source->codecs.video_rtpmap = NULL;
	file_source->listeners = NULL;
	file_source->destroyed = 0;
	janus_mutex_init(&file_source->mutex);
	janus_mutex_lock(&mountpoints_mutex);
	g_hash_table_insert(mountpoints, GINT_TO_POINTER(file_source->id), file_source);
	janus_mutex_unlock(&mountpoints_mutex);
	if(live) {
		GError *error = NULL;
		g_thread_try_new(file_source->name, &janus_streaming_filesource_thread, file_source, &error);
		if(error != NULL) {
			JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the live filesource thread...\n", error->code, error->message ? error->message : "??");
			if(file_source->name)
				g_free(file_source->name);
			if(description)
				g_free(description);
			if(file_source_source)
				g_free(file_source_source);
			g_free(file_source);
			return NULL;
		}
	}
	return file_source;
}


/* FIXME Thread to send RTP packets from a file (on demand) */
static void *janus_streaming_ondemand_thread(void *data) {
	JANUS_LOG(LOG_VERB, "Filesource (on demand) RTP thread starting...\n");
	janus_streaming_session *session = (janus_streaming_session *)data;
	if(!session) {
		JANUS_LOG(LOG_ERR, "Invalid session!\n");
		g_thread_unref(g_thread_self());
		return NULL;
	}
	janus_streaming_mountpoint *mountpoint = session->mountpoint;
	if(!mountpoint) {
		JANUS_LOG(LOG_ERR, "Invalid mountpoint!\n");
		g_thread_unref(g_thread_self());
		return NULL;
	}
	if(mountpoint->streaming_source != janus_streaming_source_file) {
		JANUS_LOG(LOG_ERR, "[%s] Not an file source mountpoint!\n", mountpoint->name);
		g_thread_unref(g_thread_self());
		return NULL;
	}
	if(mountpoint->streaming_type != janus_streaming_type_on_demand) {
		JANUS_LOG(LOG_ERR, "[%s] Not an on-demand file source mountpoint!\n", mountpoint->name);
		g_thread_unref(g_thread_self());
		return NULL;
	}
	janus_streaming_file_source *source = mountpoint->source;
	if(source == NULL || source->filename == NULL) {
		g_thread_unref(g_thread_self());
		JANUS_LOG(LOG_ERR, "[%s] Invalid file source mountpoint!\n", mountpoint->name);
		return NULL;
	}
	JANUS_LOG(LOG_VERB, "[%s] Opening file source %s...\n", mountpoint->name, source->filename);
	FILE *audio = fopen(source->filename, "rb");
	if(!audio) {
		JANUS_LOG(LOG_ERR, "[%s] Ooops, audio file missing!\n", mountpoint->name);
		g_thread_unref(g_thread_self());
		return NULL;
	}
	JANUS_LOG(LOG_VERB, "[%s] Streaming audio file: %s\n", mountpoint->name, source->filename);
	/* Buffer */
	char *buf = calloc(1024, sizeof(char));
	if(buf == NULL) {
		JANUS_LOG(LOG_FATAL, "[%s] Memory error!\n", mountpoint->name);
		g_thread_unref(g_thread_self());
		return NULL;
	}
	char *name = g_strdup(mountpoint->name ? mountpoint->name : "??");
	/* Set up RTP */
	gint16 seq = 1;
	gint32 ts = 0;
	rtp_header *header = (rtp_header *)buf;
	header->version = 2;
	header->markerbit = 1;
	header->type = mountpoint->codecs.audio_pt;
	header->seq_number = htons(seq);
	header->timestamp = htonl(ts);
	header->ssrc = htonl(1);	/* The gateway will fix this anyway */
	/* Timer */
	struct timeval now, before;
	gettimeofday(&before, NULL);
	now.tv_sec = before.tv_sec;
	now.tv_usec = before.tv_usec;
	time_t passed, d_s, d_us;
	/* Loop */
	gint read = 0;
	janus_streaming_rtp_relay_packet packet;
	while(!g_atomic_int_get(&stopping) && !mountpoint->destroyed && !session->stopping && !session->destroyed) {
		/* See if it's time to prepare a frame */
		gettimeofday(&now, NULL);
		d_s = now.tv_sec - before.tv_sec;
		d_us = now.tv_usec - before.tv_usec;
		if(d_us < 0) {
			d_us += 1000000;
			--d_s;
		}
		passed = d_s*1000000 + d_us;
		if(passed < 18000) {	/* Let's wait about 18ms */
			usleep(1000);
			continue;
		}
		/* Update the reference time */
		before.tv_usec += 20000;
		if(before.tv_usec > 1000000) {
			before.tv_sec++;
			before.tv_usec -= 1000000;
		}
		/* If not started or paused, wait some more */
		if(!session->started || session->paused || !mountpoint->enabled)
			continue;
		/* Read frame from file... */
		read = fread(buf + RTP_HEADER_SIZE, sizeof(char), 160, audio);
		if(feof(audio)) {
			/* FIXME We're doing this forever... should this be configurable? */
			JANUS_LOG(LOG_VERB, "[%s] Rewind! (%s)\n", name, source->filename);
			fseek(audio, 0, SEEK_SET);
			continue;
		}
		if(read < 0)
			break;
		if(mountpoint->active == FALSE)
			mountpoint->active = TRUE;
		//~ JANUS_LOG(LOG_VERB, " ... Preparing RTP packet (pt=%u, seq=%u, ts=%u)...\n",
			//~ header->type, ntohs(header->seq_number), ntohl(header->timestamp));
		//~ JANUS_LOG(LOG_VERB, " ... Read %d bytes from the audio file...\n", read);
		/* Relay on all sessions */
		packet.data = header;
		packet.length = RTP_HEADER_SIZE + read;
		packet.is_video = 0;
		/* Backup the actual timestamp and sequence number */
		packet.timestamp = ntohl(packet.data->timestamp);
		packet.seq_number = ntohs(packet.data->seq_number);
		/* Go! */
		janus_streaming_relay_rtp_packet(session, &packet);
		/* Update header */
		seq++;
		header->seq_number = htons(seq);
		ts += 160;
		header->timestamp = htonl(ts);
		header->markerbit = 0;
	}
	JANUS_LOG(LOG_VERB, "[%s] Leaving filesource (ondemand) thread\n", name);
	g_free(name);
	g_free(buf);
	fclose(audio);
	g_thread_unref(g_thread_self());
	return NULL;
}

/* FIXME Thread to send RTP packets from a file (live) */
static void *janus_streaming_filesource_thread(void *data) {
	JANUS_LOG(LOG_VERB, "Filesource (live) thread starting...\n");
	janus_streaming_mountpoint *mountpoint = (janus_streaming_mountpoint *)data;
	if(!mountpoint) {
		JANUS_LOG(LOG_ERR, "Invalid mountpoint!\n");
		g_thread_unref(g_thread_self());
		return NULL;
	}
	if(mountpoint->streaming_source != janus_streaming_source_file) {
		JANUS_LOG(LOG_ERR, "[%s] Not an file source mountpoint!\n", mountpoint->name);
		g_thread_unref(g_thread_self());
		return NULL;
	}
	if(mountpoint->streaming_type != janus_streaming_type_live) {
		JANUS_LOG(LOG_ERR, "[%s] Not a live file source mountpoint!\n", mountpoint->name);
		g_thread_unref(g_thread_self());
		return NULL;
	}
	janus_streaming_file_source *source = mountpoint->source;
	if(source == NULL || source->filename == NULL) {
		JANUS_LOG(LOG_ERR, "[%s] Invalid file source mountpoint!\n", mountpoint->name);
		g_thread_unref(g_thread_self());
		return NULL;
	}
	JANUS_LOG(LOG_VERB, "[%s] Opening file source %s...\n", mountpoint->name, source->filename);
	FILE *audio = fopen(source->filename, "rb");
	if(!audio) {
		JANUS_LOG(LOG_ERR, "[%s] Ooops, audio file missing!\n", mountpoint->name);
		g_thread_unref(g_thread_self());
		return NULL;
	}
	JANUS_LOG(LOG_VERB, "[%s] Streaming audio file: %s\n", mountpoint->name, source->filename);
	/* Buffer */
	char *buf = calloc(1024, sizeof(char));
	if(buf == NULL) {
		JANUS_LOG(LOG_FATAL, "[%s] Memory error!\n", mountpoint->name);
		g_thread_unref(g_thread_self());
		return NULL;
	}
	char *name = g_strdup(mountpoint->name ? mountpoint->name : "??");
	/* Set up RTP */
	gint16 seq = 1;
	gint32 ts = 0;
	rtp_header *header = (rtp_header *)buf;
	header->version = 2;
	header->markerbit = 1;
	header->type = mountpoint->codecs.audio_pt;
	header->seq_number = htons(seq);
	header->timestamp = htonl(ts);
	header->ssrc = htonl(1);	/* The gateway will fix this anyway */
	/* Timer */
	struct timeval now, before;
	gettimeofday(&before, NULL);
	now.tv_sec = before.tv_sec;
	now.tv_usec = before.tv_usec;
	time_t passed, d_s, d_us;
	/* Loop */
	gint read = 0;
	janus_streaming_rtp_relay_packet packet;
	while(!g_atomic_int_get(&stopping) && !mountpoint->destroyed) {
		/* See if it's time to prepare a frame */
		gettimeofday(&now, NULL);
		d_s = now.tv_sec - before.tv_sec;
		d_us = now.tv_usec - before.tv_usec;
		if(d_us < 0) {
			d_us += 1000000;
			--d_s;
		}
		passed = d_s*1000000 + d_us;
		if(passed < 18000) {	/* Let's wait about 18ms */
			usleep(1000);
			continue;
		}
		/* Update the reference time */
		before.tv_usec += 20000;
		if(before.tv_usec > 1000000) {
			before.tv_sec++;
			before.tv_usec -= 1000000;
		}
		/* If paused, wait some more */
		if(!mountpoint->enabled)
			continue;
		/* Read frame from file... */
		read = fread(buf + RTP_HEADER_SIZE, sizeof(char), 160, audio);
		if(feof(audio)) {
			/* FIXME We're doing this forever... should this be configurable? */
			JANUS_LOG(LOG_VERB, "[%s] Rewind! (%s)\n", name, source->filename);
			fseek(audio, 0, SEEK_SET);
			continue;
		}
		if(read < 0)
			break;
		if(mountpoint->active == FALSE)
			mountpoint->active = TRUE;
		// JANUS_LOG(LOG_VERB, " ... Preparing RTP packet (pt=%u, seq=%u, ts=%u)...\n",
			// header->type, ntohs(header->seq_number), ntohl(header->timestamp));
		// JANUS_LOG(LOG_VERB, " ... Read %d bytes from the audio file...\n", read);
		/* Relay on all sessions */
		packet.data = header;
		packet.length = RTP_HEADER_SIZE + read;
		packet.is_video = 0;
		/* Backup the actual timestamp and sequence number */
		packet.timestamp = ntohl(packet.data->timestamp);
		packet.seq_number = ntohs(packet.data->seq_number);
		/* Go! */
		janus_mutex_lock_nodebug(&mountpoint->mutex);
		g_list_foreach(mountpoint->listeners, janus_streaming_relay_rtp_packet, &packet);
		janus_mutex_unlock_nodebug(&mountpoint->mutex);
		/* Update header */
		seq++;
		header->seq_number = htons(seq);
		ts += 160;
		header->timestamp = htonl(ts);
		header->markerbit = 0;
	}
	JANUS_LOG(LOG_VERB, "[%s] Leaving filesource (live) thread\n", name);
	g_free(name);
	g_free(buf);
	fclose(audio);
	g_thread_unref(g_thread_self());
	return NULL;
}

/* FIXME Test thread to relay RTP frames coming from gstreamer/ffmpeg/others */
static void *janus_streaming_relay_thread(void *data) {
	JANUS_LOG(LOG_VERB, "Starting streaming relay thread\n");
	janus_streaming_mountpoint *mountpoint = (janus_streaming_mountpoint *)data;
	if(!mountpoint) {
		JANUS_LOG(LOG_ERR, "Invalid mountpoint!\n");
		g_thread_unref(g_thread_self());
		return NULL;
	}
	if(mountpoint->streaming_source != janus_streaming_source_rtp) {
		JANUS_LOG(LOG_ERR, "[%s] Not an RTP source mountpoint!\n", mountpoint->name);
		g_thread_unref(g_thread_self());
		return NULL;
	}
	janus_streaming_rtp_source *source = mountpoint->source;
	if(source == NULL) {
		JANUS_LOG(LOG_ERR, "[%s] Invalid RTP source mountpoint!\n", mountpoint->name);
		g_thread_unref(g_thread_self());
		return NULL;
	}
	gint audio_port = source->audio_port;
	gint video_port = source->video_port;
	/* Socket stuff */
	struct sockaddr_in audio_address, video_address;
	int audio_fd = 0;
	if(audio_port >= 0) {
		audio_fd = socket(AF_INET, SOCK_DGRAM, 0);
		int yes = 1;	/* For setsockopt() SO_REUSEADDR */
		setsockopt(audio_fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));
		audio_address.sin_family = AF_INET;
		audio_address.sin_port = htons(audio_port);
		audio_address.sin_addr.s_addr = INADDR_ANY;
		if(bind(audio_fd, (struct sockaddr *)(&audio_address), sizeof(struct sockaddr)) < 0) {
			JANUS_LOG(LOG_ERR, "[%s] Bind failed for audio (port %d)...\n", mountpoint->name, audio_port);
			g_thread_unref(g_thread_self());
			return NULL;
		}
		JANUS_LOG(LOG_VERB, "[%s] Audio listener bound to port %d\n", mountpoint->name, audio_port);
	}
	int video_fd = 0;
	if(video_port >= 0) {
		video_fd = socket(AF_INET, SOCK_DGRAM, 0);
		int yes = 1;	/* For setsockopt() SO_REUSEADDR */
		setsockopt(video_fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));
		video_address.sin_family = AF_INET;
		video_address.sin_port = htons(video_port);
		video_address.sin_addr.s_addr = INADDR_ANY;
		if(bind(video_fd, (struct sockaddr *)(&video_address), sizeof(struct sockaddr)) < 0) {
			JANUS_LOG(LOG_ERR, "[%s] Bind failed for video (%d)...\n", mountpoint->name, video_port);
			g_thread_unref(g_thread_self());
			return NULL;
		}
		JANUS_LOG(LOG_VERB, "[%s] Video listener bound to port %d\n", mountpoint->name, video_port);
	}
	char *name = g_strdup(mountpoint->name ? mountpoint->name : "??");
	/* Needed to fix seq and ts */
	uint32_t a_last_ssrc = 0, a_last_ts = 0, a_base_ts = 0, a_base_ts_prev = 0,
			v_last_ssrc = 0, v_last_ts = 0, v_base_ts = 0, v_base_ts_prev = 0;
	uint16_t a_last_seq = 0, a_base_seq = 0, a_base_seq_prev = 0,
			v_last_seq = 0, v_base_seq = 0, v_base_seq_prev = 0;
	/* Loop */
	socklen_t addrlen;
	struct sockaddr_in remote;
	int resfd = 0, bytes = 0;
	struct pollfd fds[2];
	char buffer[1500];
	memset(buffer, 0, 1500);
	janus_streaming_rtp_relay_packet packet;
	while(!g_atomic_int_get(&stopping) && !mountpoint->destroyed) {
		/* Wait for some data */
		fds[0].fd = 0;
		fds[0].events = 0;
		fds[0].revents = 0;
		if(audio_fd > 0) {
			fds[0].fd = audio_fd;
			fds[0].events = POLLIN;
		}
		fds[1].fd = 0;
		fds[1].events = 0;
		fds[1].revents = 0;
		if(video_fd > 0) {
			fds[1].fd = video_fd;
			fds[1].events = POLLIN;
		}
		resfd = poll(fds, 2, 1000);
		if(resfd < 0) {
			JANUS_LOG(LOG_ERR, "[%s] Error polling... %d (%s)\n", mountpoint->name, errno, strerror(errno));
			break;
		} else if(resfd == 0) {
			/* No data, keep going */
			continue;
		}
		if(audio_fd && (fds[0].revents & POLLIN)) {
			/* Got something audio (RTP) */
			fds[0].revents = 0;
			if(mountpoint->active == FALSE)
				mountpoint->active = TRUE;
			addrlen = sizeof(remote);
			bytes = recvfrom(audio_fd, buffer, 1500, 0, (struct sockaddr*)&remote, &addrlen);
			// JANUS_LOG(LOG_VERB, "************************\nGot %d bytes on the audio channel...\n", bytes);
			/* If paused, ignore this packet */
			if(!mountpoint->enabled)
				continue;
			rtp_header *rtp = (rtp_header *)buffer;
			// JANUS_LOG(LOG_VERB, " ... parsed RTP packet (ssrc=%u, pt=%u, seq=%u, ts=%u)...\n",
				// ntohl(rtp->ssrc), rtp->type, ntohs(rtp->seq_number), ntohl(rtp->timestamp));
			/* Relay on all sessions */
			packet.data = rtp;
			packet.length = bytes;
			packet.is_video = 0;
			/* Do we have a new stream? */
			if(ntohl(packet.data->ssrc) != a_last_ssrc) {
				a_last_ssrc = ntohl(packet.data->ssrc);
				JANUS_LOG(LOG_INFO, "[%s] New audio stream! (ssrc=%u)\n", name, a_last_ssrc);
				a_base_ts_prev = a_last_ts;
				a_base_ts = ntohl(packet.data->timestamp);
				a_base_seq_prev = a_last_seq;
				a_base_seq = ntohs(packet.data->seq_number);
			}
			a_last_ts = (ntohl(packet.data->timestamp)-a_base_ts)+a_base_ts_prev+960;	/* FIXME We're assuming Opus here... */
			packet.data->timestamp = htonl(a_last_ts);
			a_last_seq = (ntohs(packet.data->seq_number)-a_base_seq)+a_base_seq_prev+1;
			packet.data->seq_number = htons(a_last_seq);
			// JANUS_LOG(LOG_VERB, " ... updated RTP packet (ssrc=%u, pt=%u, seq=%u, ts=%u)...\n",
				// ntohl(rtp->ssrc), rtp->type, ntohs(rtp->seq_number), ntohl(rtp->timestamp));
			packet.data->type = mountpoint->codecs.audio_pt;
			/* Is there a recorder? */
			if(source->arc) {
				JANUS_LOG(LOG_HUGE, "[%s] Saving audio frame (%d bytes)\n", name, bytes);
				janus_recorder_save_frame(source->arc, buffer, bytes);
			}
			/* Backup the actual timestamp and sequence number set by the restreamer, in case switching is involved */
			packet.timestamp = ntohl(packet.data->timestamp);
			packet.seq_number = ntohs(packet.data->seq_number);
			/* Go! */
			janus_mutex_lock(&mountpoint->mutex);
			g_list_foreach(mountpoint->listeners, janus_streaming_relay_rtp_packet, &packet);
			janus_mutex_unlock(&mountpoint->mutex);
			continue;
		}
		if(video_fd && (fds[1].revents & POLLIN)) {
			/* Got something video (RTP) */
			fds[1].revents = 0;
			if(mountpoint->active == FALSE)
				mountpoint->active = TRUE;
			addrlen = sizeof(remote);
			bytes = recvfrom(video_fd, buffer, 1500, 0, (struct sockaddr*)&remote, &addrlen);
			//~ JANUS_LOG(LOG_VERB, "************************\nGot %d bytes on the video channel...\n", bytes);
			/* If paused, ignore this packet */
			if(!mountpoint->enabled)
				continue;
			rtp_header *rtp = (rtp_header *)buffer;
			//~ JANUS_LOG(LOG_VERB, " ... parsed RTP packet (ssrc=%u, pt=%u, seq=%u, ts=%u)...\n",
				//~ ntohl(rtp->ssrc), rtp->type, ntohs(rtp->seq_number), ntohl(rtp->timestamp));
			/* Relay on all sessions */
			packet.data = rtp;
			packet.length = bytes;
			packet.is_video = 1;
			/* Do we have a new stream? */
			if(ntohl(packet.data->ssrc) != v_last_ssrc) {
				v_last_ssrc = ntohl(packet.data->ssrc);
				JANUS_LOG(LOG_INFO, "[%s] New video stream! (ssrc=%u)\n", name, v_last_ssrc);
				v_base_ts_prev = v_last_ts;
				v_base_ts = ntohl(packet.data->timestamp);
				v_base_seq_prev = v_last_seq;
				v_base_seq = ntohs(packet.data->seq_number);
			}
			v_last_ts = (ntohl(packet.data->timestamp)-v_base_ts)+v_base_ts_prev+4500;	/* FIXME We're assuming 15fps here... */
			packet.data->timestamp = htonl(v_last_ts);
			v_last_seq = (ntohs(packet.data->seq_number)-v_base_seq)+v_base_seq_prev+1;
			packet.data->seq_number = htons(v_last_seq);
			//~ JANUS_LOG(LOG_VERB, " ... updated RTP packet (ssrc=%u, pt=%u, seq=%u, ts=%u)...\n",
				//~ ntohl(rtp->ssrc), rtp->type, ntohs(rtp->seq_number), ntohl(rtp->timestamp));
			packet.data->type = mountpoint->codecs.video_pt;
			/* Is there a recorder? */
			if(source->vrc) {
				JANUS_LOG(LOG_HUGE, "[%s] Saving video frame (%d bytes)\n", name, bytes);
				janus_recorder_save_frame(source->vrc, buffer, bytes);
			}
			/* Backup the actual timestamp and sequence number set by the restreamer, in case switching is involved */
			packet.timestamp = ntohl(packet.data->timestamp);
			packet.seq_number = ntohs(packet.data->seq_number);
			/* Go! */
			janus_mutex_lock(&mountpoint->mutex);
			g_list_foreach(mountpoint->listeners, janus_streaming_relay_rtp_packet, &packet);
			janus_mutex_unlock(&mountpoint->mutex);
			continue;
		}
	}
	JANUS_LOG(LOG_VERB, "[%s] Leaving streaming relay thread\n", name);
	g_free(name);
	g_thread_unref(g_thread_self());
	return NULL;
}

static void janus_streaming_relay_rtp_packet(gpointer data, gpointer user_data) {
	janus_streaming_rtp_relay_packet *packet = (janus_streaming_rtp_relay_packet *)user_data;
	if(!packet || !packet->data || packet->length < 1) {
		JANUS_LOG(LOG_ERR, "Invalid packet...\n");
		return;
	}
	janus_streaming_session *session = (janus_streaming_session *)data;
	if(!session || !session->handle) {
		// JANUS_LOG(LOG_ERR, "Invalid session...\n");
		return;
	}
	if(!session->started || session->paused) {
		// JANUS_LOG(LOG_ERR, "Streaming not started yet for this session...\n");
		return;
	}

	/* Make sure there hasn't been a publisher switch by checking the SSRC */
	if(packet->is_video) {
		if(ntohl(packet->data->ssrc) != session->context.v_last_ssrc) {
			session->context.v_last_ssrc = ntohl(packet->data->ssrc);
			session->context.v_base_ts_prev = session->context.v_last_ts;
			session->context.v_base_ts = packet->timestamp;
			session->context.v_base_seq_prev = session->context.v_last_seq;
			session->context.v_base_seq = packet->seq_number;
		}
		/* Compute a coherent timestamp and sequence number */
		session->context.v_last_ts = (packet->timestamp-session->context.v_base_ts)
			+ session->context.v_base_ts_prev+4500;	/* FIXME When switching, we assume 15fps */
		session->context.v_last_seq = (packet->seq_number-session->context.v_base_seq)+session->context.v_base_seq_prev+1;
		/* Update the timestamp and sequence number in the RTP packet, and send it */
		packet->data->timestamp = htonl(session->context.v_last_ts);
		packet->data->seq_number = htons(session->context.v_last_seq);
		if(gateway != NULL)
			gateway->relay_rtp(session->handle, packet->is_video, (char *)packet->data, packet->length);
		/* Restore the timestamp and sequence number to what the publisher set them to */
		packet->data->timestamp = htonl(packet->timestamp);
		packet->data->seq_number = htons(packet->seq_number);
	} else {
		if(ntohl(packet->data->ssrc) != session->context.a_last_ssrc) {
			session->context.a_last_ssrc = ntohl(packet->data->ssrc);
			session->context.a_base_ts_prev = session->context.a_last_ts;
			session->context.a_base_ts = packet->timestamp;
			session->context.a_base_seq_prev = session->context.a_last_seq;
			session->context.a_base_seq = packet->seq_number;
		}
		/* Compute a coherent timestamp and sequence number */
		session->context.a_last_ts = (packet->timestamp-session->context.a_base_ts)
			+ session->context.a_base_ts_prev+960;	/* FIXME When switching, we assume Opus and so a 960 ts step */
		session->context.a_last_seq = (packet->seq_number-session->context.a_base_seq)+session->context.a_base_seq_prev+1;
		/* Update the timestamp and sequence number in the RTP packet, and send it */
		packet->data->timestamp = htonl(session->context.a_last_ts);
		packet->data->seq_number = htons(session->context.a_last_seq);
		if(gateway != NULL)
			gateway->relay_rtp(session->handle, packet->is_video, (char *)packet->data, packet->length);
		/* Restore the timestamp and sequence number to what the publisher set them to */
		packet->data->timestamp = htonl(packet->timestamp);
		packet->data->seq_number = htons(packet->seq_number);
	}

	return;
}
